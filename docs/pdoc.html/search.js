window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "ediff", "modulename": "ediff", "kind": "module", "doc": "<h2 id=\"package-ediff\">Package: EDIFF</h2>\n\n<p>Processing of electron diffraction patterns.</p>\n\n<ul>\n<li>Input:\n<ul>\n<li>Image file = an experimental 2D electron diffraction pattern.</li>\n<li>CIF file = a description the expected/theoretical crystal structure.</li>\n</ul></li>\n<li>Output:\n<ul>\n<li>Comparison of the <em>experimental</em> and <em>theoretical</em> diffractogram.</li>\n<li>If the two difractograms are equivalent, the sample has been identified.</li>\n</ul></li>\n<li>Technical notes + additional help:\n<ul>\n<li>CIF files can be obtained from www - see ediff.pcryst for details.</li>\n<li>Quick start examples/demos - <a href=\"https://mirekslouf.github.io/ediff/docs\"><a href=\"https://mirekslouf.github.io/ediff/docs\">https://mirekslouf.github.io/ediff/docs</a></a></li>\n</ul></li>\n</ul>\n\n<p>EDIFF modules:</p>\n\n<ul>\n<li>ediff.bkg = background subtraction for 1D diffraction profiles</li>\n<li>ediff.bkg2d = background subtraction for 2D diffraction patterns  </li>\n<li>ediff.calibration = calibration of SAED diffractograms (pixels -> q-vectors)</li>\n<li>ediff.center = find the center of an arbitrary 2D-diffraction pattern</li>\n<li>ediff.io = input/output operations (read diffractogram, set plot params...)</li>\n<li>ediff.gcryst = functions from geometric/general crystallography</li>\n<li>ediff.mcryst = calculate monocrystal diffraction patterns</li>\n<li>ediff.pcryst = calculate polycrystal/powder diffraction patterns</li>\n<li>ediff.radial = calculate the 1D-radial profile from a 2D-diffraction pattern</li>\n</ul>\n"}, {"fullname": "ediff.bkg", "modulename": "ediff.bkg", "kind": "module", "doc": "<h2 id=\"module-ediffbkg\">Module: ediff.bkg</h2>\n\n<p>Background subtraction in 1D diffraction profiles.    </p>\n\n<ul>\n<li>This module just imports key objects from external bground package.</li>\n<li>The source code and documentation are rather brief (basically just imports).</li>\n<li>The comments inside the code describe how it works (= how it can be used).</li>\n<li>Complete documentation of bground package: <a href=\"https://pypi.org/project/bground\">https://pypi.org/project/bground</a></li>\n</ul>\n"}, {"fullname": "ediff.bkg2d", "modulename": "ediff.bkg2d", "kind": "module", "doc": "<h2 id=\"module-ediffbkg2d\">Module: ediff.bkg2d</h2>\n\n<p>Subtract background in 2D diffraction patterns.</p>\n"}, {"fullname": "ediff.calibration", "modulename": "ediff.calibration", "kind": "module", "doc": "<h2 id=\"module-ediffcalibration\">Module: ediff.calibration</h2>\n\n<p>The calibration of electron diffraction patterns:</p>\n\n<ul>\n<li>The original diffraction pattern\nshows intensities as a function of <em>distance-in-pixels</em>.</li>\n<li>The calibrated diffraction pattern\nshows intensities as a function of <em>distance-in-q-vectors</em>.</li>\n<li>The term <em>distance-in-q-vectors</em>\nmeans that the distances = magnitudes of q-vector in [1/A].</li>\n<li>This module gives the <em>calibration constant</em>,\nwhich converts <em>distance-in-pixels</em> to <em>distance-in-q-vectors</em>.</li>\n<li>The final conversion is very simple:\n<code>distance_in_q = distance_in_pixels * calibration_constant</code></li>\n</ul>\n\n<p>How to determine the <code>calibration_constant</code>:</p>\n\n<ul>\n<li>In EDIFF, the calibration constant is calculated in\nediff.calibration.Calculate</li>\n<li>The calculation is simplified for known microscopes in\nediff.calibration.Microscopes </li>\n<li>Links to real-life examples are given at GitHub pages:\n<a href=\"https://mirekslouf.github.io/ediff/docs\">https://mirekslouf.github.io/ediff/docs</a></li>\n</ul>\n"}, {"fullname": "ediff.calibration.Calculate", "modulename": "ediff.calibration", "qualname": "Calculate", "kind": "class", "doc": "<p>A class with functions to calculate the <em>calibration constant</em>.</p>\n\n<ul>\n<li>The meaning of <em>calibration constant</em> is explained\nabove on the top of ediff.calibration module.</li>\n<li>The calculation of <em>calibration constant</em> by means of\nediff.calibration.Calculate functions is shown below.</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># EDIFF :: calculation of calibration constant</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ediff</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ed</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Note: two functions below use ELD and XRD profiles as arguments.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># - both ELD and XRD profiles are 1D diffraction patterns</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># - ELD = experimental electron diffractogram, radially averaged</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># - XRD = theoretical X-ray diffractogram, calculated in ediff.pcryst </span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (1) Calibration constant from the whole ELD and XRD profiles.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (If the max.peak in ELD corresponds to the max.peak in XRD.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">calibration_constant</span> <span class=\"o\">=</span> \\\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Calculate</span><span class=\"o\">.</span><span class=\"n\">from_max_peaks</span><span class=\"p\">(</span><span class=\"n\">ELD</span><span class=\"p\">,</span> <span class=\"n\">XRD</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (2) Calibration constant from selected parts of ELD and XRD profiles.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (If the max.peak in ELD does not correspond to the max.peak in XRD,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (we define the peak for calibration in specific ranges/regions. </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">calibration_constant</span> <span class=\"o\">=</span> \\\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Calculate</span><span class=\"o\">.</span><span class=\"n\">from_max_peaks_in_range</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"n\">ELD</span><span class=\"p\">,</span> <span class=\"n\">XRD</span><span class=\"p\">,</span> <span class=\"n\">eld_range</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">50</span><span class=\"p\">,</span><span class=\"mi\">120</span><span class=\"p\">),</span> <span class=\"n\">xrd_range</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">2.0</span><span class=\"p\">,</span><span class=\"mf\">2.5</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (3) Calibration constant from known microscope parameters.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (3a) Simple case - known microscope with default parameters</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (more details and examples =&gt; ediff.calibration.Microscopes</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">my_TEM</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Microscopes</span><span class=\"o\">.</span><span class=\"n\">TecnaiVeleta</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">calibration_constant</span> <span class=\"o\">=</span> \\\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Calculate</span><span class=\"o\">.</span><span class=\"n\">from_microscope_parameters</span><span class=\"p\">(</span><span class=\"n\">my_TEM</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (3b) General case - arbitrary microscope</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (the four parameters below must be known for given microscope</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">calibration_constant</span> <span class=\"o\">=</span> \\\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Calculate</span><span class=\"o\">.</span><span class=\"n\">from_microscope_parameters</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"n\">voltage_kV</span> <span class=\"o\">=</span> <span class=\"mi\">120</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"n\">camera_length_mm</span> <span class=\"o\">=</span> <span class=\"mi\">170</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"n\">camera_pixel_size_um</span> <span class=\"o\">=</span> <span class=\"mf\">13.2</span><span class=\"p\">,</span> <span class=\"n\">binning</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n"}, {"fullname": "ediff.calibration.Calculate.from_max_peaks", "modulename": "ediff.calibration", "qualname": "Calculate.from_max_peaks", "kind": "function", "doc": "<p>Calibration constant from the <em>maximal</em> peaks on ELD and PXRD profiles.</p>\n\n<ul>\n<li>ELD/XRD profiles represent 1D electron/X-ray diffraction patterns.</li>\n<li>More info about ELD/XRD profiles in EDIFF\n=&gt; see the docs of ediff.io.read_profile function.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>eld_profile</strong> (str or numpy.array):\nThe <em>eld_profile</em> (ELD) is\nan electron diffraction profile in EDIFF format.\nIt can come as file (if <em>eld_profile</em> = str = filename)\nor array (if <em>eld_profile</em> = numpy.array).</li>\n<li><strong>xrd_profile</strong> (str or numpy.array):\nThe <em>xrd_profile</em> (XRD) is\nan X-rayd diffraction profile in EDIFF format.\nIt can come as file (if <em>xrd_profile</em> = str = filename)\nor array (if <em>xrd_profile</em> = numpy.array).</li>\n<li><strong>messages</strong> (bool, optional, default is True):\nIf <em>messages</em> = True,\nprint some information\nand the final calibration constant to stdout.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>calibration constant</strong> (float):\nThe multiplicative constant that converts\nED-profile X-coordinate-in-pixels\nto X-coordinate-in-q-vectors [1/A].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eld_profile</span>, </span><span class=\"param\"><span class=\"n\">xrd_profile</span>, </span><span class=\"param\"><span class=\"n\">messages</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.calibration.Calculate.from_max_peaks_in_range", "modulename": "ediff.calibration", "qualname": "Calculate.from_max_peaks_in_range", "kind": "function", "doc": "<p>Calibration constant from the <em>selected</em> peaks on ED and PXRD profiles.</p>\n\n<ul>\n<li>ELD/XRD profiles represent 1D electron/X-ray diffraction patterns.</li>\n<li>More info about ELD/XRD profiles in EDIFF\n=&gt; see the docs of the ediff.io.Profile.read function.</li>\n<li>The peaks are selected using arguments <em>eld_range</em> and <em>xrd_range</em>.\n<ul>\n<li>Both arguments are tuples of two floats = x-ranges.</li>\n<li>Only the maximal peaks in given ranges are considered.</li>\n<li>ED range is in [pixels] and PXRD range is given in [q-vectors].</li>\n</ul></li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>eld_profile</strong> (str or numpy.array):\nThe <em>eld_profile</em> is\nan electron diffraction profile in EDIFF format.\nIt can come as file (if <em>eld_profile</em> = str = filename)\nor array (if <em>eld_profile</em> = numpy.array).</li>\n<li><strong>xrd_profile</strong> (str or numpy.array):\nThe <em>xrd_profile</em> is\nan X-rayd diffraction profile in EDIFF format.\nIt can come as file (if <em>xrd_profile</em> = str = filename)\nor array (if <em>xrd_profile</em> = numpy.array).</li>\n<li><strong>eld_range</strong> (tuple of two floats, optional, default is None):\nThe x-range in 1D ED profile,\nin which we should search for the maximal peak.\nThe ED x-range is given in [pixels].</li>\n<li><strong>xrd_range</strong> (tuple of two floats, optional, default is None):\nThe x-range in 1D XRD profile,\nin which we should search for the maximal peak.\nThe XRD x-range is given in [q-vectors].</li>\n<li><strong>messages</strong> (bool, optional, default is True):\nIf <em>messages</em> = True,\nprint some information\nand the final calibration constant to stdout.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>calibration constant</strong> (float):\nThe multiplicative constant that converts\nED-profile X-coordinate-in-pixels\nto X-coordinate-in-q-vectors [1/A].</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>ELD profile = 1D radially averaged\npowder electron diffraction pattern\n<ul>\n<li>in EDIFF, it is obtained from an experimental 2D difractogram</li>\n</ul></li>\n<li>XRD profile = 1D powder X-ray diffraction pattern\n<ul>\n<li>in EDIFF, it is calculated from a standard CIF file\n= Crystallographic Information File</li>\n</ul></li>\n<li>EDIFF format of ELD and XRD profiles employed in EDIFF package\n<ul>\n<li>ELD and XRD profiles can come in the form of files or np.arrays</li>\n<li>Columns in files &lt;=&gt; rows in np.arrays (we use: <em>unpack=True</em>)</li>\n<li>ELD profile = 3 cols = pixels, intensity, bkgr-corrected-intsty</li>\n<li>XRD profile = 4 cols = 2theta[deg], S[1/A], q[1/A], norm-intsty</li>\n</ul></li>\n<li>EDIFF calculation of ELD and XRD profiles is best seen from examples:\n<ul>\n<li><a href=\"https://mirekslouf.github.io/ediff/docs\"><a href=\"https://mirekslouf.github.io/ediff/docs\">https://mirekslouf.github.io/ediff/docs</a></a> -> worked example</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">eld_profile</span>,</span><span class=\"param\">\t<span class=\"n\">xrd_profile</span>,</span><span class=\"param\">\t<span class=\"n\">eld_range</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">xrd_range</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">messages</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.calibration.Calculate.from_microscope_parameters", "modulename": "ediff.calibration", "qualname": "Calculate.from_microscope_parameters", "kind": "function", "doc": "<p>Calibration constant from microscope-specific parameters.</p>\n\n<ul>\n<li>The calibration constant can be estimated from parameters,\nwhich are typical of given microscope + camera system.</li>\n<li>The parameters we need to know are: (i) accelerating_voltage,\n(ii) camera_length, (iii) camera_pixel_size, and (iv) binning.</li>\n<li>The parameters can be inserted directly OR\nin the form of microscope object, which contains them.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>microscope</strong> (microscope object, optional, default is None):\nOne of the microscopes defined in ediff.calibration.Microscopes.</li>\n<li><strong>voltage_kV</strong> (int, optional, default is None):\nAccelerating voltage in [kV].\nIf {None} it is taken from {microscope} argument.</li>\n<li><strong>camera_length_mm</strong> (float, optional, default is None):\nCamera lenght in [mm].\nIf {None} it is taken from {microscope} argument.\nWARNING: this must be the <em>real_camera_length</em>;\nsee the <em>Note on camera lenght</em> section below for more details.</li>\n<li><strong>camera_pixel_size_um</strong> (float, optional, default is None):\nCamera pixel size in [um].\nIf {None} it is taken from {microscope} argument.</li>\n<li><strong>binning</strong> (int):\nBinning=1,2,4,... increases camera_pixel_size (1x,2x,4x,...).\nIf {None} it is taken from {microscope} argument.</li>\n<li><strong>verbose</strong> (bool, optional, default is False):\nIf {True}, the function prints outputs to stdnout.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>calibration constant</strong> (float):\nThe multiplicative constant that converts\nED-profile X-coordinate-in-pixels\nto X-coordinate-in-q-vectors [1/A].</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>This calculation is based on four microscope parameters,\nnamely: (i) accelerating_voltage, (ii) camera_length_mm,\n(iii) camera_pixel_size, and (iv) binning.</li>\n<li>Nevertheless, three of the parameters may change\nfrom experiment to experiment:\n<ul>\n<li><em>accelerating_voltage_kV</em> for given TEM\ncan be changed by user (although it is not typical).</li>\n<li><em>camera_length_mm</em> is routinely adjusted\nto see the desired range of difractions;\nthe TEM software usually displays some information\nabout the nominal camera length.</li>\n<li><em>binning</em> averages the neighboring pixels of the camera;\nFor example, the binning=1,2,4,...\nincreases the pixel size 1x,2x,4x,..</li>\n</ul></li>\n</ul>\n\n<h6 id=\"note-on-camera-length\">Note on camera length</h6>\n\n<ul>\n<li>The <em>nominal camera length</em> shown by the microscope (<em>D</em>)\nmay be different from <em>real camera length</em>,\nwhich is the argument (camera_lenght_um) used in the calculation.\n<ul>\n<li>Possible reasons: Exact amera position (bottom x upper camera),\nprojective lenses (which may change the magnification\nof the diffraction pattern.</li>\n<li>Real-life solution: we need to know real <em>camera_length_mm</em>\nfor each theoretical/nominal/TEM-software-displayed\ncammera length <em>D</em>!</li>\n</ul></li>\n<li>Note: For known/calibrated microscopes\n(that are defined in ediff.calibration.Microscopes)\nwe insert the <em>nominal camera length</em>, because we know\nthe conversion coefficient from nominal to real camera length.\nHere, for the arbitrary microscope, we have to insert\nthe <em>real camera length</em> in order to get the correct result.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">microscope</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">voltage_kV</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">camera_length_mm</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">camera_pixel_size_um</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">binning</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.calibration.Microscopes", "modulename": "ediff.calibration", "qualname": "Microscopes", "kind": "class", "doc": "<p>A dataclass containing know/calibrated microscopes.</p>\n\n<ul>\n<li>The microscopes are defined as subclasses.</li>\n<li>More precisely, the microscopes are sub-dataclasses.</li>\n<li>The calibrated microscopes can be used to determine calibration constant.</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">How</span> <span class=\"n\">to</span> <span class=\"n\">calculate</span> <span class=\"n\">calibration</span> <span class=\"n\">constant</span> <span class=\"k\">for</span> <span class=\"n\">known</span><span class=\"o\">/</span><span class=\"n\">calibrated</span> <span class=\"n\">microscope</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ediff</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ed</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (1) Define the microscope + its parameters</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (a) Simple case - all parameters at their default/standard values</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">my_TEM</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Microscopes</span><span class=\"o\">.</span><span class=\"n\">TecnaiVeleta</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (b) Intermediate case - standard values + camera lenght changed</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">my_TEM</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Microscopes</span><span class=\"o\">.</span><span class=\"n\">TecnaiVeleta</span><span class=\"p\">(</span><span class=\"n\">D</span><span class=\"o\">=</span><span class=\"mi\">750</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (c) The most comlex case - multiple parameters have changed</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">my_TEM</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Microscopes</span><span class=\"o\">.</span><span class=\"n\">TecnaiVeleta</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">D</span><span class=\"o\">=</span><span class=\"mi\">750</span><span class=\"p\">,</span> <span class=\"n\">voltage_kV</span><span class=\"o\">=</span><span class=\"mi\">80</span><span class=\"p\">,</span> <span class=\"n\">binning</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (2) Calculate the calibration constant</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">const</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Calculate</span><span class=\"o\">.</span><span class=\"n\">from_microscope_parameters</span><span class=\"p\">(</span><span class=\"n\">my_TEM</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Technical notes:</p>\n\n<ul>\n<li>Each calibrated {microscope + camera} system\nis defined by one ediff.calibration.Microscopes subclass.</li>\n<li>Example: {Tecnai microscope + Veleta camera}\nis represented by ediff.calibration.Microscopes.TecnaiVeleta subclass.</li>\n<li>The final calculation of the calibration constant is made by the\ngeneral function: ediff.calibration.Calculate.from_microscope_parameters,\nbut in this case the arguments of the function are pre-defined\nwithin each subclass (such as TecnaiVeleta, TecnaiMorada...).</li>\n</ul>\n"}, {"fullname": "ediff.calibration.Microscopes.TecnaiVeleta", "modulename": "ediff.calibration", "qualname": "Microscopes.TecnaiVeleta", "kind": "class", "doc": "<p>The default parameters for\nthe microscope/camera = Tecnai/Veleta3G.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>voltage_kV</strong> (float, default is 120):\nThe accelerating voltage, typical of given system.</li>\n<li><strong>D</strong> (float, default is 1000):\nThe <em>nominal camera length</em> from the control software.</li>\n<li><strong>D_to_CL_coefficient</strong> (float, default is 1/4.5):\nThe coefficient to convert\n<em>nominal camera lenght</em> to <em>real_camera_length</em> in mm.\nThis coefficient is specific for given system\nas the <em>nominal</em> and <em>real</em> camera length may be different.</li>\n<li><strong>camera_pixel_size_um</strong> (float, default is 13.2):\nThe camera pixel size = a constant for given camera.</li>\n<li><strong>binning</strong> (int, default is 2):\nThe binning, which is typical of given system.</li>\n</ul>\n"}, {"fullname": "ediff.calibration.Microscopes.TecnaiMorada", "modulename": "ediff.calibration", "qualname": "Microscopes.TecnaiMorada", "kind": "class", "doc": "<p>The default parameters for\nthe microscope/camera = Tecnai/Morada.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>voltage_kV</strong> (float, default is 120):\nThe accelerating voltage, typical of given system.</li>\n<li><strong>D</strong> (float, default is 660):\nThe <em>nominal camera length</em> from the control software.</li>\n<li><strong>D_to_CL_coefficient</strong> (float, default is 1/4):\nThe coefficient to convert\n<em>nominal camera lenght</em> to <em>real_camera_length</em>.\nThis coefficient is specific for given system\nas the <em>nominal</em> and <em>real</em> camera length may be different.</li>\n<li><strong>camera_pixel_size_um</strong> (float, default is 9.0):\nThe camera pixel size = a constant for given camera.</li>\n<li><strong>binning</strong> (int, default is 4):\nThe binning, which is typical of given system.</li>\n</ul>\n"}, {"fullname": "ediff.calibration.Utils", "modulename": "ediff.calibration", "qualname": "Utils", "kind": "class", "doc": "<p>Utilities for the calculation of calibration constants.</p>\n"}, {"fullname": "ediff.calibration.Utils.electron_wavelength", "modulename": "ediff.calibration", "qualname": "Utils.electron_wavelength", "kind": "function", "doc": "<p>Calculate relativistic wavelenght of accelerated electrons.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>U</strong> (float):\nAccelerating voltage [kV].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Lambda</strong> (float):\nRelativistic wavelenght of electrons,\nwhich were accelerated with the voltage <em>U</em>[kV]\nin an electron microscope.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">U</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.calibration.Utils.calc_final_calibration_constants", "modulename": "ediff.calibration", "qualname": "Utils.calc_final_calibration_constants", "kind": "function", "doc": "<p>Calculate final calibration constants\nfrom known CC and camera_pixel_size.</p>\n\n<ul>\n<li>Once we know <em>CC</em>, <em>camera_pixel_size</em>, and <em>binning</em>,\nthe calculation of the final calibration constants\nis surprisingly easy.</li>\n<li>The full justification of the calculation\nis given in the comments of the source code below.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>camera_constant_mmA</strong> (float):\nThe camera constant (from R<em>d = CL</em>Lambda = CC) in [mmA].</li>\n<li><strong>camera_pixel_size_um</strong> (float):\nThe real dimension of one pixel of the camera (detector) in [um].</li>\n<li><strong>binning</strong> (int):\nBinning = 1,2,4,... increases pixel size (1x,2x,4x,...)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>R_calibration, S_calibration, q_calibration</strong> (three floats):\n<ul>\n<li>R_calibration = the camera pixel size in [mm].</li>\n<li>S_calibration = the camera pixel size in S-vector units [1/A].</li>\n<li>q_calibration = the camaera pixel size in q-vector units [1/A].</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">camera_pixel_size_um</span>, </span><span class=\"param\"><span class=\"n\">binning</span>, </span><span class=\"param\"><span class=\"n\">camera_constant_mmA</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.calibration.Utils.print_final_calibration_constants", "modulename": "ediff.calibration", "qualname": "Utils.print_final_calibration_constants", "kind": "function", "doc": "<p>Print all constants employed in calibraton to stdout in nice form.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>Lambda</strong> (float):\nThe relativistic wavelenght of electrons in [A].</li>\n<li><strong>CL</strong> (float):\nThe camera lenght (from R<em>d = CL</em>Lambda) in [mm].</li>\n<li><strong>CC</strong> (float):\nThe camera constant (from R<em>d = CL</em>Lambda = CC) in [mmA].</li>\n<li><strong>R_calibration</strong> (float,):\nThe camera pixel size in [mm].</li>\n<li><strong>S_calibration</strong> (float):\nThe camera pixel size in S-vector units [1/A].</li>\n<li><strong>q_calibration</strong> (TYPE):\nThe camera pixel size in q-vector units [1/A].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The arguments are just nicely printed in stdout.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Lambda</span>, </span><span class=\"param\"><span class=\"n\">CL</span>, </span><span class=\"param\"><span class=\"n\">CC</span>, </span><span class=\"param\"><span class=\"n\">R_calibration</span>, </span><span class=\"param\"><span class=\"n\">S_calibration</span>, </span><span class=\"param\"><span class=\"n\">q_calibration</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.calibration.Utils.calibrate_and_normalize_eld_profile", "modulename": "ediff.calibration", "qualname": "Utils.calibrate_and_normalize_eld_profile", "kind": "function", "doc": "<p>Calibrate and normalize ELD profile.</p>\n\n<ul>\n<li>Assumption: The ELD profile is in EDIFF format as described below.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>eld_profile</strong> (numpy.array):\nThe original/non-calibrated ELD profile in EDIFF format.\nThe details are in the <em>Technical notes</em> section below.</li>\n<li><strong>calibration_constant</strong> (float):\nThe calibration constant,\nwhich converts <em>distance-in-pixels</em> to <em>distance-in-q-vectors</em>.\nThe details are in the <em>Technical notes</em> section below.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>eld_profile</strong> (numpy.array):\nThe calibrated and normalized ELD profile (in EDIFF format).</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>ELD profile in EDIFF format\n= text file with 3 columns + comments (starting with #).\n<ul>\n<li>EDIFF file columns\n= {pixel}, {intensity}, {bkg-corrected-intensity}.</li>\n<li>The {pixel} column\n= {distance-in-pixels-from-the-diffractogram-center}.</li>\n<li>More details concerning ELD profiles\n= the documentation of ediff.io.Profile.read function.</li>\n</ul></li>\n<li>The <em>calibration constant</em>\n= the final constant for the conversion/calibration.\n<ul>\n<li>It is explained in more detail at the initial desription\nof ediff.calibration module.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eld_profile</span>, </span><span class=\"param\"><span class=\"n\">calibration_constant</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center", "modulename": "ediff.center", "kind": "module", "doc": "<h2 id=\"module-ediffcenter\">Module: ediff.center</h2>\n\n<p>Find the center of a 2D diffraction pattern.</p>\n\n<ul>\n<li>The center determination may be surprisingly tricky in certain cases.</li>\n<li>Nevertheless, usually it is enough to call <code>CenterLocator</code> as shown below.</li>\n<li>More details and examples at GitHub: <a href=\"https://mirekslouf.github.io/ediff/docs\">https://mirekslouf.github.io/ediff/docs</a></li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Example: How to use CenterLocator and get center coordinates.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ediff</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ed</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">center</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">CenterLocator</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>   <span class=\"n\">input_image</span><span class=\"o\">=</span><span class=\"s1\">&#39;some_diffractogram.png&#39;</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>   <span class=\"n\">determination</span><span class=\"o\">=</span><span class=\"s1\">&#39;intensity&#39;</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>   <span class=\"n\">refinement</span><span class=\"o\">=</span><span class=\"s1\">&#39;sum&#39;</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>   <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">final_replot</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Determined center coordinates:&#39;</span><span class=\"p\">,</span> <span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">x1</span><span class=\"p\">,</span> <span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">y1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Refined center coordinates   :&#39;</span><span class=\"p\">,</span> <span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">x2</span><span class=\"p\">,</span> <span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">y2</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n"}, {"fullname": "ediff.center.CenterLocator", "modulename": "ediff.center", "qualname": "CenterLocator", "kind": "class", "doc": "<p>CenterLocator object : determine and refine the center of a 2D electron \ndiffraction pattern (diffractogram)</p>\n\n<p>This class detects the center of diffraction patterns. It offers several \nautomatic or manual methods and optionally refines the center position.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_image</strong> (str, path, or numpy.ndarray):\nThe input 2D diffraction image, either a file path or a NumPy array.</li>\n<li><strong>determination</strong> (str or None, optional, default=None):\nMethod used for the initial center determination.\nOptions include:\n<ul>\n<li><em>'manual'</em> : Manual detection = interactive plot where the user\nselects 3 points defining a diffraction ring with a mouse.</li>\n<li><em>'intensity'</em> : Auto-detection = the intensity center\nfrom the central region.</li>\n<li><em>'curvefit'</em> : Automatic detection = fit the intensity center\nfrom the central region using pseudo-Voigt profile.                      </li>\n<li><em>'hough'</em> : Automatic detection using Hough transform\nto find center of ring-like structures.</li>\n<li><em>'phase'</em> : Automatic detection using phase correlation\nto find the symmetry center.</li>\n<li><em>'ccorr'</em> : Automatic detection using cross-correlation\nto find the symmetry center.</li>\n<li><em>None</em> : Skip the center determination;\nit is supposed that the center coordinates\nwill be read from <em>in_file</em> argument - see below.</li>\n</ul></li>\n<li><strong>refinement</strong> (str or None, optional, default=None):\nMethod used for refining the initially detected center.\nOptions include:\n<ul>\n<li><em>'manual'</em> : Manual fine-tuning of the center along\nthe selected diffraction ring.</li>\n<li><em>'sum'</em> : Automatic refinement by maximizing the intensity sum\nthe selected diffraction ring.</li>\n<li><em>'var'</em> : Automatic refinement by minimizing intensity variance\nthe selected diffraction ring.</li>\n<li><em>'None'</em> : Skip the center refinement</li>\n</ul></li>\n<li><strong>rtype</strong> (int, default=1):\nHow to determine a radius of a difraction ring for center refinement.\nIn powder diffractograms, the diffraction rings are clearly defined.\nIn spotty diffractograms, the diffraction ring is an fictive ring\nconnecting at least three diffraction spots.\nOptions include:\n<ul>\n<li>0 : Peak matching method\n(fast and simple, but failing for non-powders, historical).</li>\n<li>1 : Radial distribution method\n(slower but more universal, new default).</li>\n</ul></li>\n<li><strong>in_file</strong> (str or None, optional, default=None):\nPath to a file from which the (previously saved)\ncenter coordinates will be loaded.</li>\n<li><strong>out_file</strong> (str or None, optional, default=None):\nPath to a file where the determined\ncenter coordinates will be saved.</li>\n<li><strong>sobel</strong> (bool, optional, default=False):\nIf True, apply Sobel filter to the image before processing.</li>\n<li><strong>heq</strong> (bool or None, optional, default=False):\nIf True, apply histogram equalization internally (display unchanged).</li>\n<li><strong>icut</strong> (float or None, optional, default=None):\nCut-off intensity level for processing the image.</li>\n<li><strong>cmap</strong> (str, optional, default='gray'):\nMatplotlib colormap name used for displaying the image.</li>\n<li><strong>csquare</strong> (int, optional, default=50):\nSize (in pixels) of the central square used for initial center search.</li>\n<li><strong>cintensity</strong> (float, optional, default=0.8):\nThreshold intensity for finding the intensity center. Pixels with a \n(relative) intensity lower than cintensity are ignored.</li>\n<li><strong>verbose</strong> (int, optional, default=0):\nVerbosity level for printing messages during processing:\n<ul>\n<li>0 : Silent mode \u2014 no messages are printed.</li>\n<li>1 : Show help messages during manual refinement only.</li>\n<li>2 : Full verbose mode \u2014 print all messages and debug information.</li>\n<li>3 : Progress mode \u2014 print brief status updates during time-consuming \nprocessing.</li>\n</ul></li>\n<li><strong>print_sums</strong> (bool, optional, default=False):\nIf True, print intensity sums after each adjustment (in manual modes).</li>\n<li><strong>final_print</strong> (bool, optional, default=True):\nIf True, print final coordinates to stdout.</li>\n<li><strong>live_plot</strong> (bool, optional, default=True):\nIf True, show live visualization of some processes if available.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The result is stored in the instance variables:\n<ul>\n<li><code>(x1, y1)</code> for the initially determined center</li>\n<li><code>(x2, y2)</code> for the refined center (if refinement is applied)</li>\n</ul></li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>The class automatically initializes and uses two internal components:\n<code>CenterDetermination</code> and <code>CenterRefinement</code>.</li>\n<li>These internal processes are hidden from the user but can be accessed \ndirectly if needed.</li>\n</ul>\n"}, {"fullname": "ediff.center.CenterLocator.output", "modulename": "ediff.center", "qualname": "CenterLocator.output", "kind": "function", "doc": "<p>Return the final results of center determination and refinement. </p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>x1</strong> (float):\nx-coordinate of the center determined\nby the <em>determination</em> method.</li>\n<li><strong>y1</strong> (float):\ny-coordinate of the center determined\nby the <em>determination</em> method.</li>\n<li><strong>x2</strong> (float):\nx-coordinate of the center after <em>refinement</em>, or same as x1 if no \nrefinement was used.</li>\n<li><strong>y2</strong> (float):\ny-coordinate of the center after <em>refinement</em>, or same as y1 if no \nrefinement was used.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The function always returns four values: (x1, y1, x2, y2).</li>\n<li>If no refinement method was used (<code>refinement=None</code>), then (x2, y2) \nwill be equal to (x1, y1).</li>\n<li>All values are rounded to one decimal place before returning.</li>\n<li>Coordinates are internally converted to float to ensure consistency \nin output.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.save_results", "modulename": "ediff.center", "qualname": "CenterLocator.save_results", "kind": "function", "doc": "<p>Save the determined and refined center coordinates to a file.</p>\n\n<p>This method writes the coordinates (x1, y1) from the <em>determination</em>\nstep and (x2, y2) from the <em>refinement</em> step to a file specified\nby the <code>out_file</code> attribute.</p>\n\n<ul>\n<li>If the file already exists, the results are appended to the end.</li>\n<li>If the file does not exist, it is created.</li>\n<li>Coordinates are formatted to four decimal places for clarity.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>If <code>self.out_file</code> is None (which is the default),\nthe method does nothing.</li>\n<li>The results are written in the format:\n<ul>\n<li>Line 1: <code>x1: value, y1: value</code></li>\n<li>Line 2: <code>x2: value, y2: value</code></li>\n</ul></li>\n<li>This method does not raise an error if the path is invalid;\nensure <code>out_file</code> is a valid writable path.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.load_results", "modulename": "ediff.center", "qualname": "CenterLocator.load_results", "kind": "function", "doc": "<p>Load center coordinates from a results file.</p>\n\n<p>This method reads a text file (defaulting to <code>self.in_file</code> or\na provided <code>path</code>) containing previously saved center coordinates.\nIt extracts coordinate pairs (x1, y1) from the determination step and\n(x2, y2) from the refinement step. All sets of values are stored\ninternally, with the most recent values assigned to instance variables \n<code>self.x1</code>, <code>self.y1</code>, <code>self.x2</code>, and <code>self.y2</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str, optional):\nPath to the results file. \nIf not provided, the method uses <code>self.in_file</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple or None</strong>: If <code>path</code> is provided and successfully loaded:\n(x1_values, y1_values) : Lists of all loaded x1 and y1 values.\nIf loading fails:\nNone</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The file is expected to contain lines in the following format:\nx1: <value>, y1: <value>\nx2: <value>, y2: <value></li>\n<li>Multiple coordinate entries can be loaded; the last set is stored in\nthe instance variables for easy access.</li>\n<li>If the file doesn't exist or is unreadable, a warning is printed and\nthe function returns None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.get_circle_pixels", "modulename": "ediff.center", "qualname": "CenterLocator.get_circle_pixels", "kind": "function", "doc": "<p>Extract pixel values along a circular path in the image.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong> (np.ndarray):\n2D grayscale image from which pixel values are extracted.</li>\n<li><strong>cx</strong> (float):\nX-coordinate (row) of the circle center.</li>\n<li><strong>cy</strong> (float):\nY-coordinate (column) of the circle center.</li>\n<li><strong>r</strong> (float):\nRadius of the circle.</li>\n<li><strong>num_points</strong> (int, optional):\nNumber of points to sample along the circular path. Default is 360.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pixels</strong> (np.ndarray):\n1D array of pixel intensity values sampled along the circular path.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">cx</span>, </span><span class=\"param\"><span class=\"n\">cy</span>, </span><span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">num_points</span><span class=\"o\">=</span><span class=\"mi\">360</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.intensity_sum", "modulename": "ediff.center", "qualname": "CenterLocator.intensity_sum", "kind": "function", "doc": "<p>Compute the sum of pixel intensities along a circular path.</p>\n\n<p>This function extracts pixel values along a circle defined by the \ngiven center coordinates (cx, cy) and radius r, then returns \nthe sum of these intensities.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>im</strong> (np.ndarray):\n2D grayscale image from which the intensities are extracted.</li>\n<li><strong>cx</strong> (float):\nX-coordinate (row) of the circle center.</li>\n<li><strong>cy</strong> (float):\nY-coordinate (column) of the circle center.</li>\n<li><strong>r</strong> (float):\nRadius of the circle.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: Sum of pixel intensities along the circular path.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">im</span>, </span><span class=\"param\"><span class=\"n\">cx</span>, </span><span class=\"param\"><span class=\"n\">cy</span>, </span><span class=\"param\"><span class=\"n\">r</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.intensity_variance", "modulename": "ediff.center", "qualname": "CenterLocator.intensity_variance", "kind": "function", "doc": "<p>Variance of intensity values of pixels of a diffraction pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong> (array of uint8):\nimage from which the diffraction pattern has been detected.</li>\n<li><strong>px</strong> (float64):\nx-coordinate of the center of the diffraction pattern.</li>\n<li><strong>py</strong> (float64):\ny-coordinate of the center of the diffraction pattern.</li>\n<li><strong>pr</strong> (float64):\nradius of the diffraction pattern.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>s</strong> (float64):\nintensity variance</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.convert_coords", "modulename": "ediff.center", "qualname": "CenterLocator.convert_coords", "kind": "function", "doc": "<p>Convert coordinates between numpy and matplotlib systems.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>x</strong> (int or float):\nThe x-coordinate in the numpy (column index) format.</li>\n<li><strong>y</strong> (int or float):\nThe y-coordinate in the numpy (row index) format.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple of (int or float, int or float)</strong>: The converted coordinates in matplotlib format, where:\n<ul>\n<li>First element corresponds to y (new x in matplotlib).</li>\n<li>Second element corresponds to x (new y in matplotlib).</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.visualize_results", "modulename": "ediff.center", "qualname": "CenterLocator.visualize_results", "kind": "function", "doc": "<p>Visualize diffractogram and its center after\ncenter determination + refinement.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>csquare</strong> (int, optional, default is None):\nIf csquare argument is given,\nonly the central square of the diffractogram will be plotted;\nthe size of the central square will be equal to csquare argument.</li>\n<li><strong>out_file</strong> (str, optional, default is None):\nIf out_file is given,\nsave the final plot to image named *out_file*.</li>\n<li><strong>out_dpi</strong> (int, optional, default is 200):\nDPI of the output image file;\nthis parameter is relevant only if out_file is given.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The output is the image of the diffractogram\nshowing also the central coordinates and refinement ring.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">csquare</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">out_file</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">out_dpi</span><span class=\"o\">=</span><span class=\"mi\">200</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.ellipse_distortion", "modulename": "ediff.center", "qualname": "CenterLocator.ellipse_distortion", "kind": "function", "doc": "<p>Corrects elliptical distortion in an image by transforming 4 distorted \npoints (which should ideally lie on a circle) to lie on a true circle.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>img</strong> (np.ndarray):\nInput image (2D numpy array) containing an elliptical diffraction \npattern.</li>\n<li><strong>show</strong> (bool, optional):\nIf True, displays the original and corrected images. \nDefault is True.</li>\n<li><strong>method</strong> (str, optional):\nPoint selection method: 'manual' or 'auto'.\n<ul>\n<li>'manual': User clicks four points on the image.</li>\n<li>'auto': Automatically detects the four brightest Bragg spots \n(not yet implemented).</li>\n</ul></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>corrected</strong> (np.ndarray):\nThe distortion-corrected image.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">show</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">method</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination", "modulename": "ediff.center", "qualname": "CenterDetermination", "kind": "class", "doc": "<p>CenterDetermination object - initial detection of a diffractogram center.</p>\n\n<p>This class is responsible for identifying the center coordinates of \na 2D diffraction pattern image using various detection methods specified \nby the user. It initializes with the input image and other parameters\nthat influence the center detection process.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>parent</strong> (CenterLocator):\nReference to the parent CenterLocator object, allowing access \nto shared attributes and methods.</li>\n<li><strong>input_image</strong> (str, path, or numpy.array):\nThe input image representing a 2D diffraction pattern, provided as \na file path or a NumPy array.</li>\n<li><strong>determination</strong> (str or None, optional, default=None):\nMethod used for the initial center determination.\nOptions include:\n<ul>\n<li>'manual'   : Manual selection of 3 points on a diffraction ring.</li>\n<li>'hough'    : Automatic detection using Hough transform.</li>\n<li>'intensity': Automatic detection based on the intensity center \nof the central region.</li>\n<li>'phase'    : Automatic detection using phase correlation to find \nthe symmetry center.</li>\n<li>'ccorr'    : Automatic detection using cross-correlation to find \nthe symmetry center.</li>\n<li>'curvefit' : Automatic detecting using pseudo-Voigt profile fitting</li>\n</ul></li>\n<li><strong>in_file</strong> (str or None, optional, default=None):\nPath to the file from which previously saved coordinates will be loaded.</li>\n<li><strong>out_file</strong> (str or None, optional, default=None):\nPath to the file where the determined coordinates will be saved.</li>\n<li><strong>sobel</strong> (bool, optional, default=False):\nIf True, apply Sobel filter to the image before processing.</li>\n<li><strong>heq</strong> (bool or None, optional, default=False):\nIf True, apply histogram equalization internally (display unchanged).</li>\n<li><strong>icut</strong> (float or None, optional, default=None):\nCut-off intensity level for processing the image.</li>\n<li><strong>cmap</strong> (str, optional, default='gray'):\nMatplotlib colormap name used for displaying the image.</li>\n<li><strong>csquare</strong> (int, optional, defaul=50):\nSize (in pixels) of the central square used for initial center search.</li>\n<li><strong>cintensity</strong> (float, optional, default=0.8):\nThreshold intensity for finding the intensity center. Pixels with a \n(relative) intensity lower than cintensity are ignored.</li>\n<li><strong>verbose</strong> (bool, optional, default=False):\nIf True, print informational verbose during the detection process.</li>\n<li><strong>print_sums</strong> (bool, optional, default=False):\nIf True, print intensity sums after each adjustment (in manual modes).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The class preprocesses the input image and then applies the specified \ncenter detection method.</li>\n<li>The detected center coordinates are stored in instance variables\n<code>x</code>, <code>y</code>, and <code>r</code>, representing the center's x-coordinate, \ny-coordinate, and radius, respectively.</li>\n</ul>\n"}, {"fullname": "ediff.center.CenterDetermination.preprocess", "modulename": "ediff.center", "qualname": "CenterDetermination.preprocess", "kind": "function", "doc": "<p>Preprocess the input image based on the selected automatic detection \nand refinement methods.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>preInit</strong> (bool, optional, default=0):\nPreprocess the original image using initialization methods such as\nhistogram equalization (heq) or contrast clipping (icut). This\nis used to enhance the input image prior to any detection or\ncorrection.</li>\n<li><strong>preHough</strong> (bool, optional, default=0):\nPerform preprocessing required for Hough transform-based automatic \ndetection. This includes edge detection and handling beamstoppers.</li>\n<li><strong>preManual, preVar, preSum, preInt</strong> (bool, optional, default=0):\nPlaceholder flags for future preprocessing needs for manual \ndetection and different refinement methods (variance, sum, \nintensity-based). Currently unused.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>edges</strong> (np.ndarray of bool, optional):\nEdge map obtained using the Canny edge detector, required for Hough\ntransform. Only returned if <code>preHough</code> is True.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This function performs different preprocessing steps depending on the\ndetection/refinement strategy selected. It is modular and supports\noptional display of intermediate results if <code>self.parent.verbose</code> is True.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">preInit</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preHough</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preManual</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preVar</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preSum</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preInt</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.sobel_filt", "modulename": "ediff.center", "qualname": "CenterDetermination.sobel_filt", "kind": "function", "doc": "<p>The Sobel filter, which is a simple 3\u00d73 kernel convolved with the image \nwhich approximates the gradient of intensity in a certain direction. \nSince the Sobel filter is a simple matrix, it can be applied across \ndatasets without concern for effects caused by changing user defined \nthresholds, and is much faster and impartial than an iterative method</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong> (TYPE):\nDESCRIPTION.</li>\n<li><strong>disp</strong> (TYPE, optional):\nDESCRIPTION. The default is False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>sobel_magnitude</strong> (TYPE):\nDESCRIPTION.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">disp</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.detection_phase", "modulename": "ediff.center", "qualname": "CenterDetermination.detection_phase", "kind": "function", "doc": "<p>Detects the center of symmetry in a diffraction image using a \ncombination of weighted intensity averaging and phase cross-correlation.</p>\n\n<p>This method performs the following steps:\n    1. Estimates an initial center using a weighted average of pixel \n       intensities.\n    2. Crops the image to focus on its central region.\n    3. Optionally normalizes the background to mitigate experimental \n       artifacts.\n    4. Computes a refined center via inversion symmetry and phase \n       cross-correlation.\n    5. Returns the final refined center coordinates.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>normalize_bg</strong> (bool, optional, default=True):\nIf True, normalize background intensity to reduce artifacts.</li>\n<li><strong>sobel</strong> (bool, optional, default=False):\nIf True, applies Sobel filtering (currently unused if not implemented)</li>\n<li><strong>disp</strong> (bool, optional, default=False):\nIf True, displays intermediate processing results.</li>\n<li><strong>masking</strong> (bool, optional, default=True):\nIf True, applies masking to exclude unwanted regions from analysis</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>r_final</strong> (float):\nEstimated row-coordinate of the image center after refinement.</li>\n<li><strong>c_final</strong> (float):\nEstimated column-coordinate of the image center after refinement.</li>\n<li><strong>None</strong> (NoneType):\nPlaceholder for future functionality (e.g., radius estimation).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">normalize_bg</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">sobel</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">disp</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">masking</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.detection_crosscorr", "modulename": "ediff.center", "qualname": "CenterDetermination.detection_crosscorr", "kind": "function", "doc": "<p>Detects the center of symmetry in a diffraction image using a \ncombination of weighted intensity averaging and cross-correlation.</p>\n\n<p>This method performs the following steps:\n    1. Estimates an initial center using the weighted average of pixel\n       intensities.\n    2. Crops the image to focus on its central region.\n    3. Optionally normalizes the background to reduce experimental\n       artifacts.\n    4. Computes a refined center by analyzing inversion symmetry \n       using cross-correlation.\n    5. Returns the final corrected center coordinates.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>normalize_bg</strong> (bool, optional, default=True):\nIf True, normalizes the background intensity to reduce illumination \nartifacts.</li>\n<li><strong>sobel</strong> (bool, optional, default=False):\nIf True, applies Sobel filtering to enhance edges prior to processing.</li>\n<li><strong>disp</strong> (bool, optional, default=False):\nIf True, displays intermediate processing results.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>r_final</strong> (float):\nEstimated row-coordinate of the image center after refinement.</li>\n<li><strong>c_final</strong> (float):\nEstimated column-coordinate of the image center after refinement.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">normalize_bg</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">sobel</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">disp</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.detection_intensity", "modulename": "ediff.center", "qualname": "CenterDetermination.detection_intensity", "kind": "function", "doc": "<p>Find center of intensity/mass of an array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (2D-numpy array):\nThe array, whose intensity center will be determined.</li>\n<li><strong>csquare</strong> (int, optional, default is 20):\nThe size/edge of the square in the (geometrical) center.\nThe intensity center will be searched only within the central\nsquare.\nReasons: To avoid other spots/diffractions and\nto minimize the effect of possible intensity assymetry\naround the center.</li>\n<li><strong>cintensity</strong> (float, optional, default is 0.8):\nThe intensity fraction.\nWhen searching the intensity center, we will consider only\npixels with intensity &gt; max.intensity.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xc, yc</strong> (float,float):\nXY-coordinates of the intensity/mass center of the array.\nRound XY-coordinates if you use them for image/array calculations.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">csquare</span>, </span><span class=\"param\"><span class=\"n\">cintensity</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">sobel</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.detection_Hough", "modulename": "ediff.center", "qualname": "CenterDetermination.detection_Hough", "kind": "function", "doc": "<p>Perform Hough transform to detect the center of diffraction patterns \nwith optional real-time visualization and a final image showing all \ndetected circles.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>plot_results</strong> (int, binary):\nIf 1, shows the final detected circle.</li>\n<li><strong>sobel</strong> (bool, optional, default=False):\nIf True, applies Sobel filtering to enhance edges prior to processing.</li>\n<li><strong>sobel</strong></li>\n<li><strong>live_plot</strong> (bool, optional, default=False):\nIf True, animates the circle detection process and shows all \ndetected circles.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>self.x</strong> (float64):\nx-coordinate of the detected center.</li>\n<li><strong>self.y</strong> (float64):\ny-coordinate of the detected center.</li>\n<li><strong>self.r</strong> (float64):\nRadius of the detected circle.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">sobel</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">live_plot</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.detection_curvefit", "modulename": "ediff.center", "qualname": "CenterDetermination.detection_curvefit", "kind": "function", "doc": "<p>Detects the center of a diffraction pattern by fitting a 2D pseudo-Voigt \nfunction to the central region of the image.</p>\n\n<p>This method:\n    - Crops a square region around the image center.\n    - Fits a 2D pseudo-Voigt peak to the cropped region.\n    - Returns the refined center coordinates in the original image space.\n    - Optionally visualizes the result.\n    - Falls back to the crop center if fitting fails.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>plot_results</strong> (bool, optional, default=False):\nIf True, displays the fitted center location on the image.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>x</strong> (float):\nRefined x-coordinate of the center (column index).</li>\n<li><strong>y</strong> (float):\nRefined y-coordinate of the center (row index).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.detection_3points", "modulename": "ediff.center", "qualname": "CenterDetermination.detection_3points", "kind": "function", "doc": "<p>Semi-automated detection of the diffraction pattern center using manual \nselection of 3 points.</p>\n\n<p>This method allows the user to manually select 3 points along a visible \ndiffraction ring in the image to define a circle. Once selected, \nthe center and radius of the circle are automatically computed. After \nthat, the user can manually adjust the center position using\nan interactive interface.</p>\n\n<h2 id=\"user-controls-during-point-selection\">User Controls (during point selection)</h2>\n\n<ul>\n<li><strong>'1'</strong>: Add a point at the current mouse cursor position \n(max 3 points).</li>\n<li><strong>'2'</strong>: Delete the most recently added point.</li>\n<li><strong>'3'</strong>: Delete the point closest to the mouse cursor.</li>\n<li><strong>'d'</strong>: When 3 points are selected (DONE), proceed </li>\n<li><strong>Close</strong>    : Terminate the process without detecting a center.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>plot_results</strong> (int, binary, default=0):\nPlot the pattern determined by pixels selected by the user.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>self.x</strong> (float64):\nx-coordinate of the detected center</li>\n<li><strong>self.y</strong> (float64):\ny-coordinate of the detected center</li>\n<li><strong>self.r</strong> (float64):\nradius of the detected center\n(if available, othervise returns None)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.adjustment_3points", "modulename": "ediff.center", "qualname": "CenterDetermination.adjustment_3points", "kind": "function", "doc": "<p>Manual/interactive refinement of the diffraction pattern center\nafter initial detection via 3 points.</p>\n\n<h2 id=\"user-controls-during-point-selection\">User Controls (during point selection)</h2>\n\n<p>This method allows the user to fine-tune the estimated\ncenter and radius of a diffraction ring,\n(which was determined manually by selecting 3 points)\nby means of the following interactive keyboard controls:</p>\n\n<ul>\n<li>Arrow keys (\u2190, \u2192, \u2191, \u2193): Move the center left, right, up, or down</li>\n<li><strong>'+'</strong> : Increase the radius</li>\n<li><strong>'-'</strong> : Decrease the radius</li>\n<li><strong>'b'</strong> : Increase step size (\u00d75)</li>\n<li><strong>'l'</strong> : Decrease step size (/5, with minimum step size 0.5)</li>\n<li><strong>'d'</strong>: Done \u2014 finalize the center and radius</li>\n<li>Closing the figure: Cancels refinement and returns the original input \ncenter and radius</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>fig</strong> (matplotlib.figure.Figure):\nThe figure window used for interactive refinement.</li>\n<li><strong>circle</strong> (matplotlib.patches.Circle):\nThe circle object initially defined from 3 selected points.</li>\n<li><strong>center</strong> (tuple):\nThe initial (x, y) center coordinates estimated from the selected \npoints.</li>\n<li><strong>plot_results</strong> (bool, optional, default=False):\nIf True, the results of the adjustment are visualized.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xy[0]</strong> (float):\nx-coordinate of the adjusted center of the diffraction pattern.</li>\n<li><strong>xy[1]</strong> (float):\ny-coordinate of the adjusted center of the diffraction pattern.</li>\n<li><strong>r</strong> (float):\nAdjusted radius of the diffraction ring.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>Interactive adjustments are visualized in real time.</li>\n<li>Intensity sum at the current center/radius is printed if print_sums\nis True.</li>\n<li>Arrow key defaults in Matplotlib (e.g., navigation) are temporarily \ndisabled to allow movement control.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fig</span>, </span><span class=\"param\"><span class=\"n\">circle</span>, </span><span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.calculate_circle", "modulename": "ediff.center", "qualname": "CenterDetermination.calculate_circle", "kind": "function", "doc": "<p>Calculate the center and radius of a circle defined by 3 manually \nselected points.</p>\n\n<p>Given three user-defined points (typically on a diffraction ring), this \nmethod computes the center and radius of the circle that passes through \nthem. Optionally, it visualizes the result including the circle, center, \nand selected points overlaid on the image.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>plot_results : int (binary</strong> (0 or 1)):\nIf 1, displays the image with the fitted circle and center.\nIf 0, skips visualization.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>self.x</strong> (float):\nx-coordinate of the detected circle center.</li>\n<li><strong>self.y</strong> (float):\ny-coordinate of the detected circle center.</li>\n<li><strong>self.r</strong> (float):\nRadius of the detected circle.</li>\n<li><strong>self.center</strong> (tuple[float, float]):\nThe (x, y) coordinates of the circle center.</li>\n<li><strong>self.circle</strong> (matplotlib.patches.Circle):\nA matplotlib Circle object that can be reused for future plotting.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The method uses a geometric approach to calculate the circumcenter\nand circumradius.</li>\n<li>For best visual results, ensure the selected points are well spaced \nand belong to the same circular ring.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">plot_results</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">patches</span><span class=\"o\">.</span><span class=\"n\">Circle</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.get_radius", "modulename": "ediff.center", "qualname": "CenterDetermination.get_radius", "kind": "function", "doc": "<p>Calculate the radius of a circle based on intensity profiles along \nhorizontal and vertical axes.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rtype</strong> (integer):\nMethod for radius calculation. Default is 0.\n<ul>\n<li>rtype=0 : peaks matching method</li>\n<li>rtype=1 : radial distribution method</li>\n</ul></li>\n<li><strong>im</strong> (np.ndarray):\nThe 2D image array containing the circle.</li>\n<li><strong>x</strong> (float):\nThe x-coordinate of the circle's center.</li>\n<li><strong>y</strong> (float):\nThe y-coordinate of the circle's center.</li>\n<li><strong>disp</strong> (bool, optional):\nIf True, visualizes the detected intensity profiles and peaks \n(default is False).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: The estimated radius of the circle. Defaults to 100 if no valid \nradius is detected.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rtype</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">im</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">disp</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.backend_fft", "modulename": "ediff.center", "qualname": "CenterDetermination.backend_fft", "kind": "function", "doc": "<p>Decorator to enforce the use of PocketFFTBackend when utilizing the \n<code>scipy.fft</code> module. This ensures that all FFT computations leverage \nthe optimized PocketFFT implementation, improving performance, \nparticularly for multi-threaded execution.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>f</strong> (callable):\nThe function to be wrapped, ensuring it executes within the \nPocketFFTBackend context.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>callable</strong>: A wrapped function that forces the use of PocketFFTBackend.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.calc_fft", "modulename": "ediff.center", "qualname": "CenterDetermination.calc_fft", "kind": "function", "doc": "<p>Computes the Fast Fourier Transform (FFT) using the specified function.</p>\n\n<p>This method ensures that the FFT operation is executed using \nthe PocketFFTBackend, applying optimized settings for improved efficiency.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>fft_function</strong> (callable):\nThe FFT function to be applied to the data.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>object</strong>: The result of the FFT computation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fft_function</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.auto_masking", "modulename": "ediff.center", "qualname": "CenterDetermination.auto_masking", "kind": "function", "doc": "<p>Automatically generates a binary mask for an image based on intensity \nthresholding.</p>\n\n<p>This function determines a lower intensity limit by taking a fraction \n(threshold) of the median of the highest intensity values in the image. \nThis helps filter out noise while preserving meaningful features, \navoiding the influence of hot spots.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>im</strong> (ndarray):\nInput grayscale image as a 2D NumPy array.</li>\n<li><strong>threshold</strong> (float, optional):\nA fraction (default is 0.1) of the median of the highest intensity \nvalues. Pixels with intensity above this computed limit will be \nincluded in the mask.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>mask</strong> (ndarray):\nA boolean mask (same shape as <code>im</code>), where <code>True</code> indicates pixels \nabove the threshold and <code>False</code> represents background or noise.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">im</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>, </span><span class=\"param\"><span class=\"n\">show_mask</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.visualize_center", "modulename": "ediff.center", "qualname": "CenterDetermination.visualize_center", "kind": "function", "doc": "<p>Visualize detected diffraction patterns and mark the center.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tit</strong> (string):\nname of the method used for circle detection</li>\n<li><strong>x</strong> (float64):\nx-coordinate of the detected center</li>\n<li><strong>y</strong> (float64):\ny-coordinate of the detected center</li>\n<li><strong>r</strong> (float64):\nradius of the detected center</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None.</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">r</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">rd</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterRefinement", "modulename": "ediff.center", "qualname": "CenterRefinement", "kind": "class", "doc": "<p>CenterRefinement - Final refinement of the center of a diffraction pattern.</p>\n\n<p>This class performs refinement of the detected center coordinates in a 2D\ndiffraction pattern. It supports multiple refinement methods, both manual\nand automatic, and optionally saves the refined center to a file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>parent</strong> (CenterLocator):\nReference to the parent CenterLocator object. Used to access shared\nattributes like initial center estimates and configuration flags.</li>\n<li><strong>input_image</strong> (str, Path, or numpy.ndarray):\nThe diffraction pattern image, either as a file path or a 2D NumPy array.</li>\n<li><strong>refinement</strong> (str or None, optional, default=None):\nThe refinement method to apply. Options include:\n<ul>\n<li>'manual': Manual adjustment via user interaction on the selected ring.</li>\n<li>'sum'   : Automatic refinement by maximizing the intensity sum </li>\n<li>'var'   : Automatic refinement by minimizing the intensity variance\nIf None, no refinement is applied.</li>\n</ul></li>\n<li><strong>out_file</strong> (str, optional):\nPath to a text file where the refined center coordinates will be saved.</li>\n<li><strong>heq</strong> (bool, optional, default=False):\nWhether to apply histogram equalization to the input image before\nprocessing.</li>\n<li><strong>icut</strong> (float, optional, default=None):\nCut-off intensity level for processing the image</li>\n<li><strong>cmap</strong> (str, optional, default='gray'):\nColormap to be used when displaying the image for manual refinement.</li>\n<li><strong>verbose</strong> (bool, optional, default=False):\nFlag to enable or disable informational verbose during processing.</li>\n<li><strong>print_sums</strong> (bool, optional, default=False):\nIf True, prints the sum of intensity values for the refined circle \nafter each adjustment, relevant only for manual refinement methods.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>If an unsupported refinement method is provided, the program exits with\nan error.</li>\n<li>The coordinates <code>xx</code>, <code>yy</code>, and radius <code>rr</code> can be accessed after\ninitialization for further analysis or saving.</li>\n<li>The refinement strategy relies on initial estimates provided by the parent \nobject.</li>\n<li>Manual refinement supports click-based center adjustments guided by visual \nfeedback.</li>\n<li>Sum/variance refinement automatically searches for the most likely center\nby evaluating ring statistics.</li>\n</ul>\n"}, {"fullname": "ediff.center.CenterRefinement.ref_interactive", "modulename": "ediff.center", "qualname": "CenterRefinement.ref_interactive", "kind": "function", "doc": "<p>Manual/interactive refinement of the diffraction pattern center.</p>\n\n<p>This method allows the user to fine-tune the estimated center\nand radius of a diffraction ring through interactive keyboard controls.</p>\n\n<p>An new window is opened and the user can adjust the position\nof the diffraction ring using the following keys (keyboard controls):</p>\n\n<ul>\n<li>Arrow keys (\u2190, \u2192, \u2191, \u2193): Move the center left, right, up, or down</li>\n<li>'+' : Increase the radius</li>\n<li>'-' : Decrease the radius</li>\n<li>'b' : Increase step size (\u00d75)</li>\n<li>'l' : Decrease step size (/5, with minimum step size 0.5)</li>\n<li>'d' : Done \u2014 finalize the center and radius</li>\n<li>Closing the figure: Cancels refinement and returns the original input \ncenter and radius</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>fig</strong> (matplotlib.figure.Figure):\nThe figure window used for interactive refinement.</li>\n<li><strong>circle</strong> (matplotlib.patches.Circle):\nThe circle object known from\nthe previous step = from the center determination.</li>\n<li><strong>center</strong> (tuple):\nThe initial (x, y) center coordinates from\nthe previous step = from the center determination.</li>\n<li><strong>plot_results</strong> (bool, optional, default=False):\nIf True, the results of the adjustment are visualized.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xy[0]</strong> (float):\nx-coordinate of the adjusted center of the diffraction pattern.</li>\n<li><strong>xy[1]</strong> (float):\ny-coordinate of the adjusted center of the diffraction pattern.</li>\n<li><strong>r</strong> (float):\nAdjusted radius of the diffraction ring.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>Interactive adjustments are visualized in real time.</li>\n<li>Intensity sum at the current center/radius is printed\nif <em>print_sums</em> argument is True.</li>\n<li>Arrow key defaults in Matplotlib (e.g., navigation)\nare temporarily disabled to allow movement control.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterRefinement.ref_var", "modulename": "ediff.center", "qualname": "CenterRefinement.ref_var", "kind": "function", "doc": "<p>Refine the center coordinates (px, py) and radius (pr) of a circular \ndiffraction pattern by minimizing the variance of pixel intensities \nalong the circle's border.</p>\n\n<p>This method performs iterative local search in the 8-neighbourhood \naround the current center to find a position and radius that minimize \nthe intensity variance. The refinement stops when convergence criteria \nare met or after a maximum number of iterations.</p>\n\n<p>Neighborhood pattern tested (o = current center, x = candidate center):\n    x x x   --> (px - dx, py + dy) (px, py + dy) (px + dx, py + dy)\n    x o x   --> (px - dx, py)      (px, py)      (px + dx, py)\n    x x x   --> (px - dx, py - dy) (px, py - dy) (px + dx, py - dy)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>px</strong> (float):\nInitial x-coordinate of the detected center.</li>\n<li><strong>py</strong> (float):\nInitial y-coordinate of the detected center.</li>\n<li><strong>pr</strong> (float):\nInitial radius of the detected circular pattern.</li>\n<li><strong>plot_results</strong> (int, optional (default=0)):\nWhether to plot the refinement result (1 = yes, 0 = no).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>px</strong> (float):\nRefined x-coordinate of the center.</li>\n<li><strong>py</strong> (float):\nRefined y-coordinate of the center.</li>\n<li><strong>pr</strong> (float):\nRefined radius of the circular pattern.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The function avoids overfitting to local minima by enforcing \nconvergence thresholds and consistency checks.</li>\n<li>If the refinement worsens the initial variance significantly or \nsuggests an invalid coordinate swap, the original input is preserved.</li>\n<li>Uses <code>self.parent.intensity_variance()</code> for evaluating the criterion.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterRefinement.ref_sum", "modulename": "ediff.center", "qualname": "CenterRefinement.ref_sum", "kind": "function", "doc": "<p>Refine the center coordinates (px, py) and radius (pr) of a circular \ndiffraction pattern by maximizing the summed pixel intensity along \na circular ring.</p>\n\n<p>The method uses an iterative local search strategy based on gradient \nascent in the 8-neighbourhood around the current center to find \na position and radius that maximize the intensity sum. The center \nis updated based on the best neighbor until convergence criteria \nor maximum iteration limits are met.</p>\n\n<p>Neighborhood pattern tested (o = current center, x = candidate center):\n    x x x   --> (px - dx, py + dy) (px, py + dy) (px + dx, py + dy)\n    x o x   --> (px - dx, py)      (px, py)      (px + dx, py)\n    x x x   --> (px - dx, py - dy) (px, py - dy) (px + dx, py - dy)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>px</strong> (float):\nInitial x-coordinate of the detected center.</li>\n<li><strong>py</strong> (float):\nInitial y-coordinate of the detected center.</li>\n<li><strong>pr</strong> (float):\nInitial radius of the detected circular pattern.</li>\n<li><strong>plot_results</strong> (int, optional (default=0)):\nIf set to 1, plots the final result of the refinement.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>px</strong> (float):\nRefined x-coordinate of the center.</li>\n<li><strong>py</strong> (float):\nRefined y-coordinate of the center.</li>\n<li><strong>pr</strong> (float):\nRefined radius of the circular pattern.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>Uses <code>self.parent.intensity_sum()</code> as the optimization criterion.</li>\n<li>Alternates between optimizing the center and the radius.</li>\n<li>Stops after no significant improvement over multiple iterations.</li>\n<li>If refinement worsens the result, the original values are retained.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">live_plot</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterRefinement.diagnose_landscape", "modulename": "ediff.center", "qualname": "CenterRefinement.diagnose_landscape", "kind": "function", "doc": "<p>Visualize the optimization landscape of a center refinement metric\naround a candidate center location and radius.</p>\n\n<p>This function evaluates the selected metric over a grid of positions\nin a 2D neighborhood around the given (px, py) center, using a fixed\nradius <code>pr</code>, and visualizes the results as a heatmap with contours.</p>\n\n<p>It can be useful for diagnosing whether the optimization function\n(e.g., standard deviation, median, or sum of pixel intensities) has\na smooth and well-behaved landscape, which is important for gradient\noptimization methods.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>px</strong> (float):\nX-coordinate of the candidate center.</li>\n<li><strong>py</strong> (float):\nY-coordinate of the candidate center.</li>\n<li><strong>pr</strong> (float):\nRadius of the circular region to evaluate the metric on.</li>\n<li><strong>metric</strong> (str, optional):\nThe metric to evaluate. Options are:\n<ul>\n<li>'std': standard deviation of pixel values (default)</li>\n<li>'median': median of pixel values</li>\n<li>'sum': sum of pixel values</li>\n</ul></li>\n<li><strong>search_range</strong> (float, optional, default=2.0):\nThe radius of the square region (in pixels) around the center \nto explore. The grid will extend \u00b1<code>search_range</code> in both x and y \ndirections.</li>\n<li><strong>steps</strong> (int, optional, default=21):\nThe number of points to sample along each axis (grid resolution).\nMust be an odd number to ensure the center point is included.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: This method produces a matplotlib plot and does not return any value.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span>, </span><span class=\"param\"><span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"s1\">&#39;std&#39;</span>, </span><span class=\"param\"><span class=\"n\">search_range</span><span class=\"o\">=</span><span class=\"mf\">2.0</span>, </span><span class=\"param\"><span class=\"n\">steps</span><span class=\"o\">=</span><span class=\"mi\">21</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.HandlerCircle", "modulename": "ediff.center", "qualname": "HandlerCircle", "kind": "class", "doc": "<p>Helper class for creating circular markers in matplotlib legends.</p>\n\n<p>This class customizes the legend to display circular markers instead of the \ndefault. It is intended for internal use within the module and not \nfor general use.</p>\n\n<h6 id=\"methods\">Methods</h6>\n\n<p>create_artists(legend, \n               orig_handle, \n               xdescent,\n               ydescent, \n               width, \n               height, \n               fontsize, \n               trans):\n    Creates a circular marker for the legend based on the original handle's \n    properties.</p>\n\n<p>Parameters for <code>create_artists</code>:\n    legend : matplotlib.legend.Legend\n        The legend instance where the custom marker will be used.\n    orig_handle : matplotlib.artist.Artist\n        The original handle containing the marker properties \n        (e.g., facecolor, edgecolor).\n    xdescent : float\n        Horizontal offset adjustment for the marker.\n    ydescent : float\n        Vertical offset adjustment for the marker.\n    width : float\n        Width of the legend entry.\n    height : float\n        Height of the legend entry.\n    fontsize : float\n        Font size of the legend text.\n    trans : matplotlib.transforms.Transform\n        Transformation applied to the marker's coordinates.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>list of matplotlib.patches.Circle</strong>: A list containing a single circular marker artist.</li>\n</ul>\n", "bases": "matplotlib.legend_handler.HandlerBase"}, {"fullname": "ediff.center.HandlerCircle.create_artists", "modulename": "ediff.center", "qualname": "HandlerCircle.create_artists", "kind": "function", "doc": "<p>Return the legend artists generated.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>legend</strong> (<code>~matplotlib.legend.Legend</code>):\nThe legend for which these legend artists are being created.</li>\n<li><strong>orig_handle</strong> (<code>~matplotlib.artist.Artist</code> or similar):\nThe object for which these legend artists are being created.</li>\n<li><strong>xdescent, ydescent, width, height</strong> (int):\nThe rectangle (<em>xdescent</em>, <em>ydescent</em>, <em>width</em>, <em>height</em>) that the\nlegend artists being created should fit within.</li>\n<li><strong>fontsize</strong> (int):\nThe fontsize in pixels. The legend artists being created should\nbe scaled according to the given fontsize.</li>\n<li><strong>trans</strong> (<code>~matplotlib.transforms.Transform</code>):\nThe transform that is applied to the legend artists being created.\nTypically from unit coordinates in the handler box to screen\ncoordinates.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">legend</span>,</span><span class=\"param\">\t<span class=\"n\">orig_handle</span>,</span><span class=\"param\">\t<span class=\"n\">xdescent</span>,</span><span class=\"param\">\t<span class=\"n\">ydescent</span>,</span><span class=\"param\">\t<span class=\"n\">width</span>,</span><span class=\"param\">\t<span class=\"n\">height</span>,</span><span class=\"param\">\t<span class=\"n\">fontsize</span>,</span><span class=\"param\">\t<span class=\"n\">trans</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.PocketFFTBackend", "modulename": "ediff.center", "qualname": "PocketFFTBackend", "kind": "class", "doc": "<p>High-performance FFT backend leveraging SciPy's PocketFFT with optimized \ndefaults. This backend enhances the efficiency of Fast Fourier Transforms \n(FFT), particularly for 2D transforms, which may experience up to a 50% \nspeed improvement over standard configurations.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>__ua_domain__</strong> (str):\nUniversal array domain identifier for NumPy's SciPy-based FFT interface.</li>\n</ul>\n\n<h6 id=\"methods\">Methods</h6>\n\n<p>__ua_function__(method, args, kwargs)\n    Universal array function handler that dispatches FFT operations to the \n    corresponding PocketFFT implementation with optimized threading\n    settings.</p>\n"}, {"fullname": "ediff.center.IntensityCenter", "modulename": "ediff.center", "qualname": "IntensityCenter", "kind": "class", "doc": "<p>Simple center determination for a symmetric diffractogram.</p>\n\n<ul>\n<li>The center is determined as a center of intensity.</li>\n<li>This works well for simple, symmetric diffraction patters, which are:\n(i) without beamstopper, (ii) pre-centered, and (iii) powder-like.</li>\n<li>A real-life example of a simple symmetric diffractogram:\na good powder electron diffraction pattern from STEMDIFF software.</li>\n<li>This class is a legacy from previous EDIFF versions;\nit is kept mostly for backward compatibility.\nThe functions in this class can be (and should be)\nreplaced by a simple call of ediff.center.CenterLocator object.</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Center determination in a simple symmetric diffraction pattern</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (center = just center_of_intensity, no refinement</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (1) Old way = this IntensityCenter class:</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (old, legacy method; just center determination, no refinement</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xc</span><span class=\"p\">,</span><span class=\"n\">yc</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">IntensityCenter</span><span class=\"o\">.</span><span class=\"n\">center_of_intensity</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">arr</span><span class=\"p\">,</span> <span class=\"n\">csquare</span><span class=\"o\">=</span><span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"n\">cintensity</span><span class=\"o\">=</span><span class=\"mf\">0.8</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (2) New way = CenterLocator class:</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (newer, more universal, with center refinement and other options</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xc</span><span class=\"p\">,</span><span class=\"n\">yc</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">CenterLocator</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">determination</span><span class=\"o\">=</span><span class=\"s1\">&#39;intensity&#39;</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">refinement</span><span class=\"o\">=</span><span class=\"s1\">&#39;sum&#39;</span><span class=\"p\">,</span> \n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">csquare</span><span class=\"o\">=</span><span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"n\">cintensity</span><span class=\"o\">=</span><span class=\"mf\">0.8</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n"}, {"fullname": "ediff.center.IntensityCenter.center_of_intensity", "modulename": "ediff.center", "qualname": "IntensityCenter.center_of_intensity", "kind": "function", "doc": "<p>Find center of intensity/mass of an array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (2D-numpy array):\nThe array, whose intensity center will be determined.</li>\n<li><strong>csquare</strong> (int, optional, default is 20):\nThe size/edge of the square in the (geometrical) center.\nThe intensity center is searched only within the central square.\nReasons: To avoid other spots/diffractions and\nto minimize the effect of an intensity assymetry around center.</li>\n<li><strong>cintensity</strong> (float, optional, default is 0.8):\nThe intensity fraction.\nWhen searching the intensity center, we will consider only\npixels with intensity &gt; max.intensity.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xc,yc</strong> (float,float):\nXY-coordinates of the intensity/mass center of the array.\nRound XY-coordinates if you use them for image/array calculations.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">csquare</span><span class=\"o\">=</span><span class=\"mi\">20</span>, </span><span class=\"param\"><span class=\"n\">cintensity</span><span class=\"o\">=</span><span class=\"mf\">0.8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.gcryst", "modulename": "ediff.gcryst", "kind": "module", "doc": "<h2 id=\"module-ediffgcryst\">Module: ediff.gcryst</h2>\n\n<p>Collection of algorithms from general/geometric crystallography.</p>\n"}, {"fullname": "ediff.gcryst.CrystalCell", "modulename": "ediff.gcryst", "qualname": "CrystalCell", "kind": "class", "doc": "<p>Class defining CrystalCell object, which contains:</p>\n\n<ul>\n<li>unit cell parameters</li>\n<li>unit cell-related functions from geometrical crystallography </li>\n</ul>\n\n<p>Simple usage of the class:</p>\n\n<ul>\n<li>The following example shows key functions of CrystalCell objects.</li>\n<li>Only if you need more, continue reading the <em>Technical details</em> section.</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># CrystalCell class :: simple usage</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ediff</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ed</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Define cubic unit cell and calculate interplanar distance</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">cell</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">gcryst</span><span class=\"o\">.</span><span class=\"n\">CrystalCell</span><span class=\"o\">.</span><span class=\"n\">cubic</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mf\">4.08</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">cell</span><span class=\"o\">.</span><span class=\"n\">dhkl</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]))</span>  <span class=\"c1\"># 2.04</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Define hexagonal unit cell and calculate:</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># 1) normal vector [uvw] of lattice plane (hkl)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># 2) lattice plane (hkl) of normal vector [uvw]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">cell</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">gcryst</span><span class=\"o\">.</span><span class=\"n\">CrystalCell</span><span class=\"o\">.</span><span class=\"n\">hexagonal</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mf\">5.91</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mf\">3.49</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">cell</span><span class=\"o\">.</span><span class=\"n\">normal_of_plane</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]))</span>  <span class=\"c1\"># (2,1,0)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">cell</span><span class=\"o\">.</span><span class=\"n\">plane_of_normal</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]))</span>  <span class=\"c1\"># (1,0,0)</span>\n</code></pre>\n</div>\n\n<p>Technical details:</p>\n\n<ul>\n<li>CrystalCell is a subclass of pymatgen.core.lattice.Lattice\n<ul>\n<li>It contains all props and methods of pymatgen.core.lattice.Lattice</li>\n<li><a href=\"https://pymatgen.org/pymatgen.core.html#module-pymatgen.core.lattice\"><a href=\"https://pymatgen.org/pymatgen.core.html#module-pymatgen.core.lattice\">https://pymatgen.org/pymatgen.core.html#module-pymatgen.core.lattice</a></a></li>\n</ul></li>\n<li>CrystalCell class offers the following features:\n<ul>\n<li>Initialization with unit cell definition = using Lattice methods</li>\n<li>All properties and methods from Lattice class are fully inherited</li>\n<li>Several user-friendly function for Xtallographic calculations added</li>\n</ul></li>\n</ul>\n", "bases": "pymatgen.core.lattice.Lattice"}, {"fullname": "ediff.gcryst.CrystalCell.dhkl", "modulename": "ediff.gcryst", "qualname": "CrystalCell.dhkl", "kind": "function", "doc": "<p>Compute interplanar distance for (hkl) plane.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>hkl</strong> (array-like):\nMiller indices of the plane</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dhkl</strong> (float):\nInterplanar distance for the (hkl) plane.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">hkl</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.gcryst.CrystalCell.normal_of_plane", "modulename": "ediff.gcryst", "qualname": "CrystalCell.normal_of_plane", "kind": "function", "doc": "<p>Compute the [uvw] direction, which is normal to a given (hkl) plane.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>hkl</strong> (array-like):\nMiller indices of the plane</li>\n<li><strong>tol</strong> (float):\nTolerance for rounding small values</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple of ints</strong>: Miller indices [uvw] of the direction,\nwhich normal to (hkl) plane.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">hkl</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.gcryst.CrystalCell.plane_of_normal", "modulename": "ediff.gcryst", "qualname": "CrystalCell.plane_of_normal", "kind": "function", "doc": "<p>Compute the (hkl) plane, which is normal to a given [uvw] direction.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvw</strong> (tuple of ints):\nDirection indices [uvw]</li>\n<li><strong>tol</strong> (float):\nTolerance for rounding small values</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple of ints</strong>: Miller indices (hkl) of the plane,\nwhich is normal to [uvw] direction.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">uvw</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.gcryst.HexLattice", "modulename": "ediff.gcryst", "qualname": "HexLattice", "kind": "class", "doc": "<p>Class with functions converting <em>Miller</em> - <em>Bravais</em> - <em>Weber</em> indices.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># HexLattice class :: simple usage</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ediff</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ed</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Conversions between Miller (hkl) and Bravais (hkil) indices</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">hkil</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">gcryst</span><span class=\"o\">.</span><span class=\"n\">HexLattice</span><span class=\"o\">.</span><span class=\"n\">hkl_to_hkil</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">hkl</span>  <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">gcryst</span><span class=\"o\">.</span><span class=\"n\">HexLattice</span><span class=\"o\">.</span><span class=\"n\">hkil_to_hkl</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">&#39;</span><span class=\"si\">{</span><span class=\"n\">hkl</span><span class=\"si\">}</span><span class=\"s1\"> &lt;-&gt; </span><span class=\"si\">{</span><span class=\"n\">hkil</span><span class=\"si\">}</span><span class=\"s1\">&#39;</span><span class=\"p\">)</span>  <span class=\"c1\"># (0, 1, 0) &lt;-&gt; (0, 1, -1, 0)</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Conversions between Miller [uvw] and Weber [uvtw] indices</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">uvtw</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">gcryst</span><span class=\"o\">.</span><span class=\"n\">HexLattice</span><span class=\"o\">.</span><span class=\"n\">uvw_to_uvtw</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">uvw</span>  <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">gcryst</span><span class=\"o\">.</span><span class=\"n\">HexLattice</span><span class=\"o\">.</span><span class=\"n\">uvtw_to_uvw</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">&#39;</span><span class=\"si\">{</span><span class=\"n\">uvw</span><span class=\"si\">}</span><span class=\"s1\"> &lt;-&gt; </span><span class=\"si\">{</span><span class=\"n\">uvtw</span><span class=\"si\">}</span><span class=\"s1\">&#39;</span><span class=\"p\">)</span>  <span class=\"c1\"># (2, 1, 0) &lt;-&gt; (1, 0, -1, 0)</span>\n</code></pre>\n</div>\n"}, {"fullname": "ediff.gcryst.HexLattice.hkl_to_hkil", "modulename": "ediff.gcryst", "qualname": "HexLattice.hkl_to_hkil", "kind": "function", "doc": "<p>Convert hexagonal indices: Miller (hkl) to Bravais (hkil).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>hkl</strong> (tuple or list or array of three integers):\nMiller indices (hkl)\ndefining a crystallographic plane.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>hkil</strong> (four integers):\nBravais indices (hkil) of the crystallographic plane.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hkl</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.gcryst.HexLattice.hkil_to_hkl", "modulename": "ediff.gcryst", "qualname": "HexLattice.hkil_to_hkl", "kind": "function", "doc": "<p>Convert hexagonal indices: Bravais (hkil) to Miller (hkl).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>hkil</strong> (tuple or list or array of four integers):\nBravais indices (hkil)\ndefining a crystallographic plane.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>hkl</strong> (tuple of three integers):\nMiller indices (hkl) of the crystallographic plane.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hkil</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.gcryst.HexLattice.uvw_to_uvtw", "modulename": "ediff.gcryst", "qualname": "HexLattice.uvw_to_uvtw", "kind": "function", "doc": "<p>Convert hexagonal indices: Miller [uvw] to Weber [uvtw]</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvw</strong> (tuple or list or array of three integers):\nMiller indices [uvw]\ndefining a crystallographic direction.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>uvtw</strong> (tuple of four integers):\nWeber indices [uvtw] of the crystallographic direction.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">uvw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.gcryst.HexLattice.uvtw_to_uvw", "modulename": "ediff.gcryst", "qualname": "HexLattice.uvtw_to_uvw", "kind": "function", "doc": "<p>Convert hexagonal indices: Weber [uvtw] to Miller [uvw].</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>uvtw</strong> (tuple or list or array of four integers):\nWeber indices [uvtw]\ndefining a crystallographic direction.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>uvw</strong> (tuple of three integers):\nMiller indices [uvw] of the crystallographic direction.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">uvtw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.gcryst.ZoneAxis", "modulename": "ediff.gcryst", "qualname": "ZoneAxis", "kind": "class", "doc": "<p>Class with functions to determine <em>zone axis</em> of a 2D diffractogram.</p>\n"}, {"fullname": "ediff.gcryst.ZoneAxis.from_two_diffs", "modulename": "ediff.gcryst", "qualname": "ZoneAxis.from_two_diffs", "kind": "function", "doc": "<p>Calculate zone axis [uvw] from (hkl) of 2 diffractions in diff.pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>diff1</strong> (tuple or list or array of three integers):\nMiller indices (hkl) of the 1st diffraction within given zone</li>\n<li><strong>diff2</strong> (TYPE):\nMiller indices (hkl) of the 2nd diffraction within given zone.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>zone_axis</strong> (tuple of three integers):\nMiller indices [uvw] of the zone axis\ncalculated from <em>diff1</em> and <em>diff2</em>.</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>Zone axis should be perpendicular\nto any two diffractions of given zone.</li>\n<li>Therefore, it can be calculated as a vector cross-product\nof any two diffractoins of given zone.</li>\n<li>We use np.cross to calculate the cross product\nand convert the result to tuple for the sake of consistency\nas all other functions in this module return vectors as tuples.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">diff1</span>, </span><span class=\"param\"><span class=\"n\">diff2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.gcryst.ZoneAxis.from_multiple_diffs", "modulename": "ediff.gcryst", "qualname": "ZoneAxis.from_multiple_diffs", "kind": "function", "doc": "<p>Calculate zone axis [uvw] from (hkl) of N diffractions in diff.pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>diffs</strong> (list of 3-item lists = list of (hkl) of multiple diffractions):\nThe list containing (hkl) indices of multiple diffractions\nthat are supposed to correspond to one zone axis [uvw].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The list of vector cross-products is printed on the screen.\nIf all cross-products are the same (up to scale/sign),\nthen the zone axis [uvw] is correct, which means that\nit explains the presence of all <em>diffs</em>\nin the observed diffraction pattern.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">diffs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.gcryst.ZoneAxis.weiss_zone_law", "modulename": "ediff.gcryst", "qualname": "ZoneAxis.weiss_zone_law", "kind": "function", "doc": "<p>Using Wess Zone Law, calculate diffractions (hkl) for zone axis [uvw]. </p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>zone_axis</strong> (tuple or list or array of three integers):\nCrystallographic direction [uvw] that defines zone axis.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>WZL</strong> (string):\nA condition for (hkl) indices of diffractions\nthat satisfy Weis Zone Law for given zone axis/direction [uvw].</li>\n</ul>\n\n<h6 id=\"technical-note\">Technical note</h6>\n\n<ul>\n<li>The condition is a simple string.</li>\n<li>It would be more straightforward to use a SymPy expression.</li>\n<li>Nevertheless, in this simple case the \"manual symbolic calculation\"\nis quite easy and so we do not need the heavy-weight SymPy library.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zone_axis</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io", "modulename": "ediff.io", "kind": "module", "doc": "<h2 id=\"module-ediffio\">Module: ediff.io</h2>\n\n<p>Input/output functions for package EDIFF.</p>\n"}, {"fullname": "ediff.io.Lattice", "modulename": "ediff.io", "qualname": "Lattice", "kind": "class", "doc": "<p>Lattice object = crystal lattice.</p>\n\n<ul>\n<li>Lattice object is identical to pymatgen.core.Lattice: <br>\n<a href=\"https://pymatgen.org/pymatgen.core.html#module-pymatgen.core.lattice\">https://pymatgen.org/pymatgen.core.html#module-pymatgen.core.lattice</a></li>\n<li>In EDIFF:\n<ul>\n<li>Lattice can be defined by all methods of the original object.</li>\n<li>Lattice can help to define a crystal structure = ediff.io.Structure.</li>\n</ul></li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># How to define Lattice = crystall lattice using ediff.io</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ediff</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ed</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">lattice1</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">Lattice</span><span class=\"o\">.</span><span class=\"n\">cubic</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mf\">5.47</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">lattice2</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">Lattice</span><span class=\"o\">.</span><span class=\"n\">hexagonal</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mf\">5.91</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mf\">3.50</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">lattice3</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">Lattice</span><span class=\"o\">.</span><span class=\"n\">from_parameters</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">90</span><span class=\"p\">,</span> <span class=\"mi\">110</span><span class=\"p\">,</span> <span class=\"mi\">90</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "bases": "pymatgen.core.lattice.Lattice"}, {"fullname": "ediff.io.Structure", "modulename": "ediff.io", "qualname": "Structure", "kind": "class", "doc": "<p>Structure object = crystal structure.</p>\n\n<ul>\n<li>Structure object is identical to pymatgen.core.Structure: <br>\n<a href=\"https://pymatgen.org/pymatgen.core.html#module-pymatgen.core.structure\">https://pymatgen.org/pymatgen.core.html#module-pymatgen.core.structure</a></li>\n<li>In EDIFF:\n<ul>\n<li>Structure can be defined by all methods of the original object.</li>\n<li>Structure is employed in calculation of theoretical diffractograms.</li>\n</ul></li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># How to define Structure = crystal structure using ediff.io</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (0) Standard import of ediff</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ediff</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ed</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (1) Structure from the very beginning</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sg</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Fm-3m&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">lat</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">Lattice</span><span class=\"o\">.</span><span class=\"n\">cubic</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mf\">4.08</span><span class=\"p\">)</span> \n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">atoms</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;Au&#39;</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">coords</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">structure1</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">Structure</span><span class=\"o\">.</span><span class=\"n\">from_spacegroup</span><span class=\"p\">(</span><span class=\"n\">sg</span><span class=\"p\">,</span> <span class=\"n\">lat</span><span class=\"p\">,</span> <span class=\"n\">atoms</span><span class=\"p\">,</span> <span class=\"n\">coords</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (2) Structure from CIF-file</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">struct2</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">Structure</span><span class=\"o\">.</span><span class=\"n\">from_file</span><span class=\"p\">(</span><span class=\"s1\">&#39;au.cif&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "bases": "pymatgen.core.structure.Structure"}, {"fullname": "ediff.io.Diffractogram", "modulename": "ediff.io", "qualname": "Diffractogram", "kind": "class", "doc": "<p>Read and show 2D diffractograms in a simple and reproducible way.</p>\n\n<ul>\n<li>A class with two funcs (read, show); show func can be used for saving.</li>\n<li>Assumption: the diffractogram is a 2D numpy array or grayscale image.</li>\n</ul>\n"}, {"fullname": "ediff.io.Diffractogram.read", "modulename": "ediff.io", "qualname": "Diffractogram.read", "kind": "function", "doc": "<p>Read 2D diffraction pattern (=grayscale image) into 2D numpy array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>diffractogram</strong> (string or path-like object or numpy array):\nName of image that should read into numpy 2D array\nor directly the 2D numpy array representing the diffractogram.</li>\n<li><strong>itype</strong> (string ('8bit'  or '16bit')):\nType of the image: 8 or 16 bit grayscale</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>arr</strong> (2D numpy array):\nThe <em>arr</em> is the input image read to an array by means of numpy.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">diffractogram</span>, </span><span class=\"param\"><span class=\"n\">itype</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.Diffractogram.show", "modulename": "ediff.io", "qualname": "Diffractogram.show", "kind": "function", "doc": "<p>Show/plot 2D diffraction pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>diffractogram</strong> (numpy.array):\nA numpy.array object representing a 2D diffractogram image.\nIn EDIFF,\nthis array is usually obtained by ediff.ioi.read_image function.</li>\n<li><strong>icut</strong> (integer, optional, default is None):\nUpper limit of intensity shown in the diffractogram.\nThe argument <em>icut</em> is used as <em>vmax</em> in plt.imshow function.\nExample: If <em>icut</em>=300, then all intensities &gt;300 are set to 300.</li>\n<li><strong>origin</strong> ('upper' or 'lower' or None, optional, default is None):\nOrientation of the image during final rendering.\nIf the argument is None, we follow the Matplotlib default,\nwhich is <em>origin</em>='upper' = [0,0] in the upper left corner.\nAlternative: <em>origin</em>='lower' = [0,0] is in the lower left corner.</li>\n<li><strong>title</strong> (str, optional, default is None):\nIf given, then it is the title of the plot.</li>\n<li><strong>output_file</strong> (str, optional, default is None):\nName of the output file.\nIf the argument is not None, the plot is saved to <em>output_file</em>.</li>\n<li><strong>output_file_dpi</strong> (int, optional, default is 300):\nResolution of the output file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The plot is shown in the stdout\nand saved to *output_file* if requested.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">diffractogram</span>,</span><span class=\"param\">\t<span class=\"n\">icut</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_file_dpi</span><span class=\"o\">=</span><span class=\"mi\">300</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.Profile", "modulename": "ediff.io", "qualname": "Profile", "kind": "class", "doc": "<p>Read and show 1D diffraction profiles in a simple and reproducible way.</p>\n\n<ul>\n<li>A class with two funcs (read, show); show func can be used for saving.</li>\n<li>Assumption: the profile is a numpy array or text file in EDIFF format.</li>\n</ul>\n"}, {"fullname": "ediff.io.Profile.read", "modulename": "ediff.io", "qualname": "Profile.read", "kind": "function", "doc": "<p>Read the ELD or XRD profile in EDIFF format.</p>\n\n<ul>\n<li>More info about ELD/XRD profiles in EDIFF\n=&gt; see the section <em>Technical notes</em> below.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>profile</strong> (str or numpy.array):\n<ul>\n<li>If profile = str,\nwe assume a filename\nof the file with ELD or XRD profile in EDIFF format.</li>\n<li>If profile = numpy.array,\nwe assume a 2D-array\ncontaining ELD or XRD profile in EDIFF format.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>profile</strong> (2D numpy.array):\nThe array representing ELD or XRD profile in EDIFF format.\nSee section <em>Technical notes</em> below\nfor explanation of the EDIFF format of the ELD and XRD profiles.</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>ELD profile = 1D radially averaged\npowder electron diffraction pattern\n<ul>\n<li>in EDIFF, it is obtained from an experimental 2D difractogram</li>\n</ul></li>\n<li>XRD profile = 1D powder X-ray diffraction pattern\n<ul>\n<li>in EDIFF, it is calculated from a standard CIF file\n= Crystallographic Information File</li>\n</ul></li>\n<li>EDIFF format of ELD and XRD profiles employed in EDIFF package\n<ul>\n<li>ELD and XRD profiles can come in the form of files or np.arrays</li>\n<li>Columns in files &lt;=&gt; rows in np.arrays (we use: <em>unpack=True</em>)</li>\n<li>XRD profile = 4 cols = 2theta[deg], S[1/A], q[1/A], norm-intsty</li>\n<li>ELD profile = 3 cols = distance, intensity, bkgr-corrected-intsty\n<ul>\n<li>ELD {distance} = {distance-from-the-diffractogram center}</li>\n<li>The {distance} in pixels or q-vect (before/after calibration)</li>\n</ul></li>\n</ul></li>\n<li>EDIFF calculation of ELD and XRD profiles is best seen from examples:\n<ul>\n<li><a href=\"https://mirekslouf.github.io/ediff/docs\"><a href=\"https://mirekslouf.github.io/ediff/docs\">https://mirekslouf.github.io/ediff/docs</a></a> -> worked examples</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">profile</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.Profile.show", "modulename": "ediff.io", "qualname": "Profile.show", "kind": "function", "doc": "<p>Plot a 1D profile in a simple and stadnard way.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>Xvalues</strong> (array or list-like object):\nX values for plotting.</li>\n<li><strong>Yvalues</strong> (array or list-like object):\nY values for plotting.</li>\n<li><strong>Xlabel</strong> (str):\nLabel of the X-axis.</li>\n<li><strong>Ylabel</strong> (str):\nLabel of the Y-axis.</li>\n<li><strong>Xrange</strong> (list/tuple of two floats):\nX range = minimum and maximu for Xvalues to plot.</li>\n<li><strong>Yrange</strong> (list/tuple of two floats):\nY range = minimum and maximu for Yvalues to plot.</li>\n<li><strong>title</strong> (str, optional, default is None):\nThe title of the plot.</li>\n<li><strong>output_file</strong> (str, optional, default is None):\nName of the output file.\nIf the argument is not None, the plot is saved to <em>output_file</em>.</li>\n<li><strong>output_file_dpi</strong> (int, optional, default is 300):\nResolution of the output file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The plot is shown in the stdout\nand saved to *output_file* if requested.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">Xvalues</span>,</span><span class=\"param\">\t<span class=\"n\">Yvalues</span>,</span><span class=\"param\">\t<span class=\"n\">Xlabel</span>,</span><span class=\"param\">\t<span class=\"n\">Ylabel</span>,</span><span class=\"param\">\t<span class=\"n\">Xrange</span>,</span><span class=\"param\">\t<span class=\"n\">Yrange</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_file_dpi</span><span class=\"o\">=</span><span class=\"mi\">300</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.set_plot_parameters", "modulename": "ediff.io", "qualname": "set_plot_parameters", "kind": "function", "doc": "<p>Set global plot parameters (mostly for plotting in Jupyter).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>size</strong> (tuple of two floats, optional, the default is (8,6)):\nSize of the figure (width, height) in [cm].</li>\n<li><strong>dpi</strong> (int, optional, the defalut is 100):\nDPI of the figure.</li>\n<li><strong>fontsize</strong> (int, optional, the default is 8):\nSize of the font used in figure labels etc.</li>\n<li><strong>my_defaults</strong> (bool, optional, default is True):\nIf True, some reasonable additional defaults are set,\nnamely line widths and formats.</li>\n<li><strong>my_rcParams</strong> (dict, optional, default is None):\nDictionary in plt.rcParams format\ncontaining any other allowed global plot parameters.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The result is a modification of the global plt.rcParams variable.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">)</span>, </span><span class=\"param\"><span class=\"n\">dpi</span><span class=\"o\">=</span><span class=\"mi\">100</span>, </span><span class=\"param\"><span class=\"n\">fontsize</span><span class=\"o\">=</span><span class=\"mi\">8</span>, </span><span class=\"param\"><span class=\"n\">my_defaults</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">my_rcParams</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.plot_final_eld_and_xrd", "modulename": "ediff.io", "qualname": "plot_final_eld_and_xrd", "kind": "function", "doc": "<p>Final plot/comparison of ELD and XRD profiles.</p>\n\n<ul>\n<li>During the final plotting, we fine-tune the ELD calibration.</li>\n<li>This is done by iterative modification of fine_tuning constant.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>eld_profile</strong> (str or numpy.array):\nThe <em>eld_profile</em> (ELD) is\nan electron diffraction profile in EDIFF format.\nIt can come as file (if <em>eld_profile</em> = str = filename)\nor array (if <em>eld_profile</em> = numpy.array).\nMore info about ELD profiles in EDIFF\n=&gt; see docs of ediff.calibration.Calculate.from_max_peaks function.</li>\n<li><strong>xrd_profile</strong> (str or numpy.array):\nThe <em>xrd_profile</em> (XRD) is\nan X-rayd diffraction profile in EDIFF format.\nIt can come as file (if <em>xrd_profile</em> = str = filename)\nor array (if <em>xrd_profile</em> = numpy.array).\nMore info about XRD profiles in EDIFF\n=&gt; see docs of ediff.calibration.Calculate.from_max_peaks function.</li>\n<li><strong>fine_tuning</strong> (float):\nThe constant for the final fine-tuning of peak position.\nThe <em>fine_tuning</em> constant has a starting value of 1.000.\nIf ELD and XRD peaks are shifted, the constant should be adjusted.\nThe constant multiplies the X-values of ELD profile.</li>\n<li><strong>x_range</strong> (tuple of two floats):\nThe limits for X-axis (minimum and maximu q-vectors on X-axis).</li>\n<li><strong>eld_data_label</strong> (str, optional, default is 'ED experiment'):\nThe label of ELD data (= name of the electron diffraction data).</li>\n<li><strong>xrd_data_label</strong> (str, optional, the default is 'XRD calculation'):\nThe label of XRD data (= name of the X-ray diffraction data).</li>\n<li><strong>x_axis_label</strong> (str, optional, the default is '$q$ [1/\u212b]' ~ q [1/A]):\nThe label of X-axis.</li>\n<li><strong>y_axis_label</strong> (str, optiona, the default is 'Intensity'.):\nThe label of Y-axis.</li>\n<li><strong>xticks</strong> (float, optional, default is None):\nThe X-axis ticks (if not omitted, use the default).</li>\n<li><strong>yticks</strong> (float, optional, default is None):\nThe Y-axis ticks (if not omitted, use the default).</li>\n<li><strong>mxticks</strong> (float, optional, default is None):\nThe Y-axis minor ticks (if not omitted, use the default).</li>\n<li><strong>myticks</strong> (float, optional, default is None):\nThe Y-axis minor ticks (if not omitted, use the default).</li>\n<li><strong>output_file</strong> (str, optional, default is None):\nThe filename, to which the final graph should be saved.\nIf <em>output_file</em> is not None (= the default),\nthe plot is not only shown in stdout,\nbut also saved in the <em>output_file</em>.</li>\n<li><strong>output_file_dpi</strong> (int, optional, default is 300):\nThe DPI of the output graph.</li>\n<li><strong>transparent</strong> (bool, optional, default is False):\nIf <em>transparent</em> = True, then the image background is transparent.</li>\n<li><strong>CLI</strong> (bool, optional, default is False):\nIf <em>CLI</em> = True, we assume command line interface\nand the plot is not shown, just saved.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The plot is shown in the stdout\nand saved to *output_file* if requested.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">eld_profile</span>,</span><span class=\"param\">\t<span class=\"n\">xrd_profile</span>,</span><span class=\"param\">\t<span class=\"n\">fine_tuning</span>,</span><span class=\"param\">\t<span class=\"n\">x_range</span>,</span><span class=\"param\">\t<span class=\"n\">eld_data_label</span><span class=\"o\">=</span><span class=\"s1\">&#39;ED experiment&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">xrd_data_label</span><span class=\"o\">=</span><span class=\"s1\">&#39;XRD calculation&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">x_axis_label</span><span class=\"o\">=</span><span class=\"s1\">&#39;$q$ [1/\u212b]&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">y_axis_label</span><span class=\"o\">=</span><span class=\"s1\">&#39;Intensity&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">xticks</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">yticks</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">mxticks</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">myticks</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_file_dpi</span><span class=\"o\">=</span><span class=\"mi\">300</span>,</span><span class=\"param\">\t<span class=\"n\">transparent</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">CLI</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.plot_radial_distributions", "modulename": "ediff.io", "qualname": "plot_radial_distributions", "kind": "function", "doc": "<p>Plot one or more 1D-radial distrubution files in one graph.</p>\n\n<ul>\n<li>This is a rather specific function.</li>\n<li>It is employed mostly when we combine STEMDIFF and EDIFF.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_to_plot</strong> (2D-list):\n<ul>\n<li>list with several rows containing [data, linestyle, label]</li>\n<li>data = data for plotting - they can be one of the following:\n<ul>\n<li>PNG filename = str, a PNG-file = 2D diffraction pattern</li>\n<li>TXT filename = str, a text file = 1D diffraction profile</li>\n<li>2D-array = a numpy array, containg 2D diffraction pattern</li>\n<li>1D-array = a numpy array, containing 1D diffraction profile</li>\n<li>Note1: 2D-pattern = a square image/array with intensities</li>\n<li>Note2: 1D-profile = a text file/array with two cols/rows = [R,I],\nwhere R = distance from center, I = diffraction intensity</li>\n</ul></li>\n<li>linestyle = matplotlib.pyplot format, such as 'r-' (red line)</li>\n<li>label = name of the data, which will appear in the plot legend</li>\n</ul></li>\n<li><strong>xlimit</strong> (int):\nmaximum of the X-axis</li>\n<li><strong>ylimit</strong> (int):\nmaximum of the Y-axis</li>\n<li><strong>output_file</strong> (int, optional, default=None):\nName of the output file;\nif the <em>output</em> argument is given,\nthe plot is not only shown on screen, but also saved in <em>output</em> file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The plot is shown in the stdout\nand saved to *output_file* if requested.</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>This function is quite flexible.</li>\n<li>It can plot one radial distribution or more.</li>\n<li>It can take data from PNG-files, TXT-files, 2D-arrays and 1D-arrays.</li>\n<li>If the input is a PNG-file or2D-array,\nthe center is just <em>estimated</em> as as the center of intensity;\ntherefore, this works only for good diffractograms with a central spot.</li>\n<li>This makes the code a more complex, but it is convenient for the user.</li>\n<li>An example of fast comparison of three 1D-distributions\ntaken from three 2D-diffractograms in the form of 16-bit PNG images:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">plot_radial_distributions</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">data_to_plot</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"p\">[</span><span class=\"s1\">&#39;sum_all_16bit.png&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;k:&#39;</span><span class=\"p\">,</span>  <span class=\"s1\">&#39;All data&#39;</span><span class=\"p\">],</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"p\">[</span><span class=\"s1\">&#39;sum_f_16bit.png&#39;</span><span class=\"p\">,</span>   <span class=\"s1\">&#39;b--&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;F data&#39;</span><span class=\"p\">],</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"p\">[</span><span class=\"s1\">&#39;sum_fd_16bit.png&#39;</span><span class=\"p\">,</span>  <span class=\"s1\">&#39;r-&#39;</span><span class=\"p\">,</span>  <span class=\"s1\">&#39;FD data&#39;</span><span class=\"p\">]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">xlimit</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"n\">ylimit</span><span class=\"o\">=</span><span class=\"mi\">300</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"s1\">&#39;sums_final_1d.png&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_to_plot</span>, </span><span class=\"param\"><span class=\"n\">xlimit</span>, </span><span class=\"param\"><span class=\"n\">ylimit</span>, </span><span class=\"param\"><span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.mcryst", "modulename": "ediff.mcryst", "kind": "module", "doc": "<h2 id=\"module-ediffmcryst\">Module: ediff.mcryst</h2>\n\n<p>Calculate monocrystalline diffraction patterns.</p>\n"}, {"fullname": "ediff.pcryst", "modulename": "ediff.pcryst", "kind": "module", "doc": "<h2 id=\"module-ediffpcryst\">Module: ediff.pcryst</h2>\n\n<p>Calculate polycrystalline/powder diffraction patterns.</p>\n\n<ul>\n<li>Theoretical powder diffractograms are usually calculated from CIF files.</li>\n<li>The short demo how to perform the calculation with ediff is shown below.</li>\n<li>More details and examples at GitHub: <a href=\"https://mirekslouf.github.io/ediff/docs\">https://mirekslouf.github.io/ediff/docs</a></li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># EDIFF/PCRYST module ::calculate diffraction pattern of NaCl</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ediff.pcryst</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># [0] Crystal structure is usually defined</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># by means of CIF = Crystallographic Information File.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># CIFs can be downloaded from: https://www.crystallography.net</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">CIF_FILE</span> <span class=\"o\">=</span> <span class=\"sa\">r</span><span class=\"s1\">&#39;./nacl_1000041.cif&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># [1] Crystal, experimental and plot parameters</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># are defined as objects XTAL, EPAR, and PPAR, respectively.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">XTAL</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">pcryst</span><span class=\"o\">.</span><span class=\"n\">Crystal</span><span class=\"p\">(</span><span class=\"n\">structure</span><span class=\"o\">=</span><span class=\"n\">CIF_FILE</span><span class=\"p\">,</span> <span class=\"n\">temp_factors</span><span class=\"o\">=</span><span class=\"mf\">0.8</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EPAR</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">pcryst</span><span class=\"o\">.</span><span class=\"n\">Experiment</span><span class=\"p\">(</span><span class=\"n\">wavelength</span><span class=\"o\">=</span><span class=\"mf\">0.71</span><span class=\"p\">,</span> <span class=\"n\">two_theta_range</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">120</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">PPAR</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">pcryst</span><span class=\"o\">.</span><span class=\"n\">PlotParameters</span><span class=\"p\">(</span><span class=\"n\">x_axis</span><span class=\"o\">=</span><span class=\"s1\">&#39;q&#39;</span><span class=\"p\">,</span> <span class=\"n\">xlim</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">10</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># [2] PXRDcalculation object</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># calculates PXRD when called/initialized</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># and contains the results for further processing.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">CALC</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">pcryst</span><span class=\"o\">.</span><span class=\"n\">PXRDcalculation</span><span class=\"p\">(</span><span class=\"n\">XTAL</span><span class=\"p\">,</span><span class=\"n\">EPAR</span><span class=\"p\">,</span><span class=\"n\">PPAR</span><span class=\"p\">,</span> <span class=\"n\">peak_profile_sigma</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># [3] Show/save CALCulation results.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (it is quite Ok to use the default settings of EDIFF package</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (for more advanced plotting you can use the saved results + arbitrary SW</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">CALC</span><span class=\"o\">.</span><span class=\"n\">print_diffractions</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">CALC</span><span class=\"o\">.</span><span class=\"n\">save_diffractions</span><span class=\"p\">(</span><span class=\"s1\">&#39;nacl_pxrd.py.diff&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">CALC</span><span class=\"o\">.</span><span class=\"n\">plot_diffractogram</span><span class=\"p\">(</span><span class=\"s1\">&#39;nacl_pxrd.py.png&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">CALC</span><span class=\"o\">.</span><span class=\"n\">save_diffractogram</span><span class=\"p\">(</span><span class=\"s1\">&#39;nacl_pxrd.py.txt&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n"}, {"fullname": "ediff.pcryst.Crystal", "modulename": "ediff.pcryst", "qualname": "Crystal", "kind": "class", "doc": "<p>Define crystal structure.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>structure</strong> (structure object):\n<ul>\n<li>The <em>structure object</em> is usually obtained from a CIF-file\n(CIF = Crystallographic Information File).</li>\n<li>The <em>CIF files</em> are available in crystallographic databases,\nsuch as <a href=\"http://www.crystallography.net\"><a href=\"http://www.crystallography.net\">http://www.crystallography.net</a></a></li>\n<li>The exact type of the object is <em>pymatgen.core.structure.Structure</em>\n<ul>\n<li>This indicates that the structure is read from CIF by means of\npymatgen package (which works behind the sceenes).</li>\n<li>This also means that the structure can be created by any\nother way available in pymatgen <a href=\"https://pymatgen.org/\"><a href=\"https://pymatgen.org/\"><a href=\"https://pymatgen.org/\">https://pymatgen.org/</a></a></a></li>\n<li>It is also possible to define structure in ediff.io,\nusing ediff.io.Lattice and ediff.io.Structure objects.</li>\n<li>Nevertheless, for common usage it is enough to\nread the structure from CIF, ignoring technical details.</li>\n</ul></li>\n</ul></li>\n<li><strong>temp_factors</strong> (float or dictionary, optional, the default is 0.8):\n<ul>\n<li>Temperature factors characterize thermal movement of atoms.</li>\n<li>If a float value is given,\nall elements have this temperature factor value.</li>\n<li>If a dictionary is given,\nthe elements have the values defined in the dictionary;\na sample input dictionary: <code>temp_factors = {'Na':1.2, 'Cl':1.1}</code>.</li>\n</ul></li>\n</ul>\n"}, {"fullname": "ediff.pcryst.Crystal.__init__", "modulename": "ediff.pcryst", "qualname": "Crystal.__init__", "kind": "function", "doc": "<ul>\n<li>Initialize Crystal object.</li>\n<li>The parameters are described above in class definition.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">structure</span>, </span><span class=\"param\"><span class=\"n\">temp_factors</span><span class=\"o\">=</span><span class=\"mf\">0.8</span></span>)</span>"}, {"fullname": "ediff.pcryst.Crystal.read_structure_from_CIF", "modulename": "ediff.pcryst", "qualname": "Crystal.read_structure_from_CIF", "kind": "function", "doc": "<p>Read crystall structure from CIF file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>CIF</strong> (str or path object):\n<ul>\n<li>The filename of CIF file.</li>\n<li>CIF = Crystallographic Information File\ncontains information about crystal structure.</li>\n<li>CIF files are usually obtained from crystallographic databases,\nsuch as <a href=\"http://www.crystallography.net\"><a href=\"http://www.crystallography.net\">http://www.crystallography.net</a></a></li>\n</ul></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>structure</strong> (structure object):\n<ul>\n<li>The exact type of the object is\n<em>pymatgen.core.structure.Structure</em>.</li>\n<li>Nevertheless, in the structure objects are usually\ncreated from CIF files (pymatgen is hidden for a common user).</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">CIF</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pcryst.Crystal.get_elements", "modulename": "ediff.pcryst", "qualname": "Crystal.get_elements", "kind": "function", "doc": "<p>Get a list of all elements, which are contained in given structure.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>structure</strong> (structure object):\nTypically, the structure objects are\ncreated by function <em>read_structure_from_CIF</em> above.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>list_of_elements</strong> (list):\nList with symbols of all elements\nthat are present in given <em>structure</em>.</li>\n</ul>\n\n<h6 id=\"technical-note\">Technical note</h6>\n\n<ul>\n<li>The elements are obtained from <em>structure</em> object.</li>\n<li>The structure object = pymatgen.core.structure.Structure.</li>\n<li>The list of element names si obtained by a set of tricks\nspecific to pymatgen-structure object.</li>\n<li>These tricks were revealed by inspecting the original\npymatgen.core.structure.Structure in Spyder,\nby means of shortcuts Ctrl+I (help) and Ctrl+G (go to code).</li>\n<li>Common users do not have to use this function.</li>\n<li>The function is just used internally, when setting\ntemperature factors of the elements contained in given <em>structure</em>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">structure</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pcryst.Crystal.get_elements_with_temp_factors", "modulename": "ediff.pcryst", "qualname": "Crystal.get_elements_with_temp_factors", "kind": "function", "doc": "<p>Get a dictionary, which contains symbols and temperature factors\nof all elements, which are present in given structure.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>structure</strong> (structure object):\nTypically, the structure objects are\ncreated by function <em>read_structure_from_CIF</em> above.</li>\n<li><strong>B</strong> (float, optional, the default is 0.8):</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>elements_with_temp_factors</strong> (dict):\nDictionary with symbols and temperature factors\nof all elements, which are present in given <em>structure</em>.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The dictionary is in the format required by pymatgen package.</li>\n<li>The pymatgen package is used for PXRD calculations,\nbut these calculations are hidden from common users.</li>\n<li>Common users do not use this function.</li>\n<li>The function is just used internally, when setting\ntemperature factors of the elements contained in given <em>structure</em>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">structure</span>, </span><span class=\"param\"><span class=\"n\">B</span><span class=\"o\">=</span><span class=\"mf\">0.8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pcryst.Experiment", "modulename": "ediff.pcryst", "qualname": "Experiment", "kind": "class", "doc": "<p>Define experimental parameters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>wavelength</strong> (float):\nWavelength of the X-rays.\nTypical values are 1.54 A (CuKa) or 0.71 A (MoKa).</li>\n<li><strong>two_theta_range</strong> (list/tuple of two floats):\nMinimal and maximal diffraction angle;\nboth values are TwoTheta angle in [deg] (for given <em>wavelength</em>).</li>\n</ul>\n"}, {"fullname": "ediff.pcryst.Experiment.__init__", "modulename": "ediff.pcryst", "qualname": "Experiment.__init__", "kind": "function", "doc": "<ul>\n<li>Initialize Experimental object.</li>\n<li>The parameters are described above in class definition.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">wavelength</span>, </span><span class=\"param\"><span class=\"n\">two_theta_range</span></span>)</span>"}, {"fullname": "ediff.pcryst.PlotParameters", "modulename": "ediff.pcryst", "qualname": "PlotParameters", "kind": "class", "doc": "<p>Define local+global parameters for plotting.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>title</strong> (str):\nTitle of the plot.</li>\n<li><strong>x_axis</strong> (str, 'TwoTheta','S','q' or 'dhkl', optional, default is 'q'):\nWhat should be shown on X-axis (diff.angle, diff.vector ...).\nDuring the processing, the data are adjusted according this argument.</li>\n<li><strong>xlim</strong> (tuple of two numbers):\nRange of X-axis = xlim parameter from matplotlib.pyplot.</li>\n<li><strong>rcParams</strong> (dict; optional, the default is empty dictionary {}):\nThe dictionary should have the format of mathplotlib.pyplot.rcParams.\nThe argmument is passed to matplotlib.pyplot.rcParams.update.\nThis enables to override current rcParams, if necessary.</li>\n</ul>\n"}, {"fullname": "ediff.pcryst.PlotParameters.__init__", "modulename": "ediff.pcryst", "qualname": "PlotParameters.__init__", "kind": "function", "doc": "<ul>\n<li>Initialize PlotParameters object.</li>\n<li>The parameters are described above in class definition.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">x_axis</span><span class=\"o\">=</span><span class=\"s1\">&#39;q&#39;</span>, </span><span class=\"param\"><span class=\"n\">xlim</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">rcParams</span><span class=\"o\">=</span><span class=\"p\">{}</span></span>)</span>"}, {"fullname": "ediff.pcryst.PeakProfiles", "modulename": "ediff.pcryst", "qualname": "PeakProfiles", "kind": "class", "doc": "<p>Define profile of diffraction peaks.</p>\n\n<ul>\n<li>This class is employed only as a namespace.</li>\n<li>It contains three functions/definitions of diffratction peak profiles.</li>\n</ul>\n"}, {"fullname": "ediff.pcryst.PeakProfiles.gaussian", "modulename": "ediff.pcryst", "qualname": "PeakProfiles.gaussian", "kind": "function", "doc": "<p>Gaussian function (~ profile for PXRD calculation).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (numpy array):\nX-variable of Gaussian function.</li>\n<li><strong>m</strong> (float):\nMean value = the center of Gaussian function.</li>\n<li><strong>s</strong> (float):\nStandard deviation = the width of Gaussian function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>NumPy array</strong>: The array with Y-values of the function; Y = Gaussian(X).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pcryst.PeakProfiles.lorentzian", "modulename": "ediff.pcryst", "qualname": "PeakProfiles.lorentzian", "kind": "function", "doc": "<p>Lorentzian function (~ profile for PXRD calculation).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (numpy array):\nX-variable of Lorentzian function.</li>\n<li><strong>m</strong> (float):\nMean value = the center of Lorentzian function.</li>\n<li><strong>s</strong> (float):\nStandard deviation = the width of Lorentzian function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>NumPy array</strong>: The array with Y-values of the functin; Y = Lorenzian(X).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pcryst.PeakProfiles.pseudo_voigt", "modulename": "ediff.pcryst", "qualname": "PeakProfiles.pseudo_voigt", "kind": "function", "doc": "<p>Pseudo-Voigt function (~ profile for PXRD calculation).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (numpy array):\nX-variable of pseudo-Voigt function.</li>\n<li><strong>m</strong> (float):\nMean value = the center of pseudo-Voigt function.</li>\n<li><strong>s</strong> (float):\nStandard deviation = the width of pseudo-Voigt function.</li>\n<li><strong>n</strong> (float, optional, the default is 0.5):\nRatio between Gaussian and Lorentzian components.\nIn the very first approximation, we can set n = 0.5.\nFor more details, see <em>Notes</em> subsection below.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>NumPy array</strong>: The array with Y-values of the functin; Y = Lorenzian(X).</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>Pseudo-Voigt function\n= linear combination of Gaussian and Lorentzian function.</li>\n<li>In the 1st approximation:\n<ul>\n<li>50/50 combination =&gt; n = 0.5</li>\n<li>sg = sigma_Gaussian\ndefined so that sg and s yielded the same FWHM</li>\n</ul></li>\n<li>more details in:\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Voigt_profile\"><a href=\"https://en.wikipedia.org/wiki/Voigt_profile\">https://en.wikipedia.org/wiki/Voigt_profile</a></a></li>\n<li><a href=\"https://lmfit.github.io/lmfit-py/builtin_models.html\"><a href=\"https://lmfit.github.io/lmfit-py/builtin_models.html\">https://lmfit.github.io/lmfit-py/builtin_models.html</a></a></li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">s</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mf\">0.5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pcryst.PXRDcalculation", "modulename": "ediff.pcryst", "qualname": "PXRDcalculation", "kind": "class", "doc": "<p>Define calculation of PXRD = powder X-ray diffraction pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>crystal</strong> (ediff.pcryst.Crystal object):\nThis object is usually prepared in advance\nas an instance of ediff.pcryst.Crystal class.</li>\n<li><strong>experiment</strong> (ediff.pcryst.Experiment object):\nThis object is usually prepared in advance\nas an instance of ediff.pcryst.Experiment class.</li>\n<li><strong>plot_parameters</strong> (ediff.pcryst.PlotParameters object):\nThis object is usually prepared in advance\nas an instance of ediff.pcryst.PlotParameters class.</li>\n<li><strong>peak_profile_sigma</strong> (float, optional, the default is 0.03):\nWidth of the calculated diffraction peaks.\nThe default = 0.03 is suitable for most of common calculations\nand corresponds to the default in older PowderCell program (n*FWHM=7).\nFor overlapping peaks it may be slightly decreased,\nwhile for more realistic diffractograms it may be slightly increased.</li>\n<li><strong>peak_profile_type</strong> (None or ediff.cryst.PeakProfiles object, optional):\nProfile of the calculated diffraction peaks.\nThe default is PeakProfiles.pseudo_voigt.\nThis default is suitable for common calculations\nand does not have to be changed (in great majority of cases).</li>\n</ul>\n"}, {"fullname": "ediff.pcryst.PXRDcalculation.__init__", "modulename": "ediff.pcryst", "qualname": "PXRDcalculation.__init__", "kind": "function", "doc": "<p>Initialize PXRDcalcualtion object.\nThe parameters are described above in class definition.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">crystal</span>,</span><span class=\"param\">\t<span class=\"n\">experiment</span>,</span><span class=\"param\">\t<span class=\"n\">plot_parameters</span>,</span><span class=\"param\">\t<span class=\"n\">peak_profile_sigma</span><span class=\"o\">=</span><span class=\"mf\">0.03</span>,</span><span class=\"param\">\t<span class=\"n\">peak_profile_type</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">PeakProfiles</span><span class=\"o\">.</span><span class=\"n\">pseudo_voigt</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "ediff.pcryst.PXRDcalculation.print_diffractions", "modulename": "ediff.pcryst", "qualname": "PXRDcalculation.print_diffractions", "kind": "function", "doc": "<p>Print the calculated diffractions to stdout.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pcryst.PXRDcalculation.save_diffractions", "modulename": "ediff.pcryst", "qualname": "PXRDcalculation.save_diffractions", "kind": "function", "doc": "<p>Save the calculated diffractions to <em>output_file</em>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>output_file</strong> (str):\nName of the output file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None; the output is the list of diffractions in the *output_file*.</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">output_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pcryst.PXRDcalculation.plot_diffractions", "modulename": "ediff.pcryst", "qualname": "PXRDcalculation.plot_diffractions", "kind": "function", "doc": "<p>Plot the calculated diffractions.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>outfile</strong> (str, optional, the default is none):\nName of the output file.\nIf not given, the plot is just shown, but not saved.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The output is the plot on the screen (and outfile).\nThis function plots just diffraction intensities,\nnot profiles.\nUse ediff.pcryst.plot_diffractions\nfor diffractogram with intensity profiles.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">outfile</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pcryst.PXRDcalculation.plot_diffractions_with_indexes", "modulename": "ediff.pcryst", "qualname": "PXRDcalculation.plot_diffractions_with_indexes", "kind": "function", "doc": "<p>Plot indexed diffractions.</p>\n\n<ul>\n<li>This function (usually) creates an interactive plot.</li>\n<li><strong>In CLI</strong> (command line) - the plot is interactive automatically.</li>\n<li><strong>In Spyder or Jupyter</strong> - type the following <em>magic commands</em>:\n<ul>\n<li>BEFORE running (switch on the interactive mode): %matplotlib qt</li>\n<li>AFTER running (back to non-interactive mode): %matplotlib inline</li>\n<li>In Spyder, the commands are typed in the Console window.</li>\n<li>In Jupyter, the commands are usually typed in separate cells.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>output_file</strong> (str, optional, default is None):\nIf the argument is not None, the output is saved to {output_file}.</li>\n<li><strong>two_theta</strong> (tuple of two floats, optional, default is None):\nIf the argument is not None, the plot uses the given two_theta\nrange.\nIf the argument is None, the plot takes the two_theta_range\nfrom the (previously defined) ediff.pcryst.Experiment object.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The output is the plot in the screen or in the {output_file}.\nIn a typical case, the plot is interactive\nso that the indexed diffractions could be inspected in detail.</li>\n</ul>\n\n<h6 id=\"technical-note\">Technical note</h6>\n\n<ul>\n<li>This function is usually called as a PXRDcalculation object method.\n<ul>\n<li>Additional parameters are usually not needed.</li>\n<li>{output_file} and {theta_range} can modify default plot params.</li>\n</ul></li>\n<li>The code below uses (sligthly modified) PyMatGen functions.\n<ul>\n<li>Reason: PyMatGen plots with diffraction indexes are quite good.</li>\n<li>Re-programing would be quite difficult, boring, and useless.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">two_theta</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.radial", "modulename": "ediff.radial", "kind": "module", "doc": "<h2 id=\"module-ediffradial\">Module: ediff.radial</h2>\n\n<p>The conversion of a 2D powder diffraction pattern\nto a 1D powder diffraction pattern = radially averaged intensity distribution.</p>\n"}, {"fullname": "ediff.radial.calc_radial_distribution", "modulename": "ediff.radial", "qualname": "calc_radial_distribution", "kind": "function", "doc": "<p>Calculate 1D radially averaged distrubution profile\nfrom 2D diffraction pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (2D-numpy array):\nThe numpy array which contains the 2D-diffractogram.</li>\n<li><strong>center</strong> (tuple/list of two floats, optional, default is None):\nThe accurate coordinates of the 2D-diffractogram.\nThis argument should be determined by ediff.center.CenterLocator\nto get the best results.\nIf not given (= if it defaults to None), the center is determined\nan approximate procedure using intensity center,\nwithout any refinement;\nthis is imprecise, especially in case of\ndiffraction patterns with a beamstopper.</li>\n<li><strong>output_file</strong> (str, optional, default is None):\nName of the output file.\nIf given, the calculated 1D profile is saved to <em>output_file</em>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>profile</strong> (2D numpy array containing two rows [R,I]):\n<ul>\n<li>R = radial_distance = dist. from the diffractogram center [pixels]</li>\n<li>I = intensity = intensities at given distances [arbitrary units]</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">center</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.radial.save_radial_distribution", "modulename": "ediff.radial", "qualname": "save_radial_distribution", "kind": "function", "doc": "<p>Save 1D radially averaged distrubution profile to output_file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>profile</strong> (2D numpy array containing two rows [R,I]):\n<ul>\n<li>R = radial_distance = dist. from the diffractogram center [pixels]</li>\n<li>I = intensity = intensities at given distances [arbitrary units]</li>\n</ul></li>\n<li><strong>filename</strong> (str):\nName of the output file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None.</strong>: The output is the radial distribution saved in a file with <em>filename</em>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">profile</span>, </span><span class=\"param\"><span class=\"n\">output_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.radial.read_radial_distribution", "modulename": "ediff.radial", "qualname": "read_radial_distribution", "kind": "function", "doc": "<p>Read 1D-radially averaged distrubution profile from a TXT-file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>filename</strong> (str):\nName of the input file;\nthe file is expected to contain two columns [distance, intensity].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>arr</strong> (2D-numpy array):\nThe array containing two columns: distance, intensity.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();