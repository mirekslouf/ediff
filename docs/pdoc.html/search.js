window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "ediff", "modulename": "ediff", "kind": "module", "doc": "<h2 id=\"package-ediff\">Package: EDIFF</h2>\n\n<p>Processing of powder electron diffraction patterns.</p>\n\n<ul>\n<li>Input:  2D powder electron diffraction pattern (raw experimental data).</li>\n<li>Output: 1D powder electron diffraction pattern (final, compared with PXRD).\n<ul>\n<li>The 1D pattern/profile is obtained by radial averaging of 2D pattern.</li>\n<li>The 1D profile is calibrated and compared with the theoretical PXRD.</li>\n<li>The calculation of theoretical PXRD patterns is a part of this package. </li>\n</ul></li>\n</ul>\n\n<p>EDIFF modules:</p>\n\n<ul>\n<li>ediff.background = background correction (employs our package BGROUND)    </li>\n<li>ediff.calibration = calibration of SAED diffractograms (pixels -> q-vectors)</li>\n<li>ediff.center = find center of an arbitrary 2D-diffraction pattern</li>\n<li>ediff.io = input/output operations (read diffractogram, set plot params...)</li>\n<li>ediff.pxrd = calculate the 1D-PXRD pattern for a known structure</li>\n<li>ediff.radial = calculate the 1D-radial profile from 2D-diffraction pattern</li>\n</ul>\n\n<p>Auxiliary package BGROUND:</p>\n\n<ul>\n<li>BGROUND is an external package, which enables a 1D background correction.</li>\n<li>It is imported during initialization to be accesible as ediff.background.</li>\n</ul>\n"}, {"fullname": "ediff.background", "modulename": "ediff.background", "kind": "module", "doc": "<h2 id=\"module-ediffbackground\">Module: ediff.background</h2>\n\n<p>Semi-automated background correction.    </p>\n\n<ul>\n<li>This module just imports key objects from external bground package.</li>\n<li>Therefore, it is just a formal incorporation of bground package to ediff.</li>\n</ul>\n\n<p>The source code is brief (just imports),\nbut it describes how it works (how it can be used).</p>\n\n<ul>\n<li>See the source code of ediff.background\nif you are interested in technical details concerning the import.</li>\n<li>See documentation of bground package at <a href=\"https://pypi.org/project/bground\">https://pypi.org/project/bground</a>\nto find out how the background correction works.</li>\n</ul>\n"}, {"fullname": "ediff.calibration", "modulename": "ediff.calibration", "kind": "module", "doc": "<h2 id=\"module-ediffcalibration\">Module: ediff.calibration</h2>\n\n<p>The calibration of electron diffraction patterns:</p>\n\n<ul>\n<li>The original diffraction pattern\nshows intensities as a function of <em>distance-in-pixels</em>.</li>\n<li>The calibrated diffraction pattern\nshows intensities as a function of <em>distance-in-q-vectors</em>.</li>\n<li>The term <em>distance-in-q-vectors</em>\nmeans that the distances = magnitudes of q-vector in [1/A].</li>\n<li>This module gives the <em>calibration constant</em>,\nwhich converts <em>distance-in-pixels</em> to <em>distance-in-q-vectors</em>.</li>\n<li>The final conversion is very simple:\n<code>distance_in_q = distance_in_pixels * calibration_constant</code></li>\n</ul>\n\n<p>Various ways how to determine the calibration constant:</p>\n\n<ul>\n<li>The calibration constant can be\n<em>calculated</em> or <em>determined</em> by various functions in this module.</li>\n<li>The calculations/determinations are not difficult,\nbut we need at least one of the following:\n<ul>\n<li>ELD and XRD profiles\n=&gt; see ediff.calibration.Calculate.from_max_peaks function</li>\n<li>some microscope parameters\n=&gt; see ediff.calibration.Calculate.from_microscope_parameters function</li>\n<li>a pre-calibrated microscope\n=&gt; see the documentation at the begiining of\nediff.calibration.Microscopes dataclass</li>\n</ul></li>\n<li>Examples in this documentation:\n<ul>\n<li><em>Calculation</em> of calibration constant for an <em>arbitrary microscope</em>\n=&gt; see ediff.calibration.Calculate class.</li>\n<li><em>Determination</em> of calibration constant for a <em>known microscope</em>\n=&gt; see ediff.calibration.Microscopes class.</li>\n<li>Real life examples can be found in EDIFF website\n<a href=\"https://mirekslouf.github.io/ediff/docs\"><a href=\"https://mirekslouf.github.io/ediff/docs\">https://mirekslouf.github.io/ediff/docs</a></a></li>\n</ul></li>\n</ul>\n"}, {"fullname": "ediff.calibration.Calculate", "modulename": "ediff.calibration", "qualname": "Calculate", "kind": "class", "doc": "<p>A class with functions to <em>calculate</em>\nthe calibration constant for <em>an arbitrary microscope</em>.</p>\n\n<p>Usage of the ediff.calibration.Calculate class functions:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Standard import of ediff</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">ediff</span> <span class=\"k\">as</span> <span class=\"nn\">ed</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Note: some functions below use ELD and XRD profiles as arguments.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># =&gt; info about ELD and XRD: ediff.calibration.Calculate.from_max_peaks</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (1) Calibration constant from the whole ELD and XRD profiles.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (If the max.peak in ELD corresponds to the max.peak in XRD</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">calibration_constant</span> <span class=\"o\">=</span> \\\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Calculate</span><span class=\"o\">.</span><span class=\"n\">from_max_peaks</span><span class=\"p\">(</span><span class=\"n\">ELD</span><span class=\"p\">,</span> <span class=\"n\">XRD</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (2) Calibration constant from selected parts of ELD and XRD profiles.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (If the max.peak in ELD corresponds to low peak in XRD or vice versa</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">calibration_constant</span> <span class=\"o\">=</span> \\\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Calculate</span><span class=\"o\">.</span><span class=\"n\">from_max_peaks_in_range</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"n\">ELD</span><span class=\"p\">,</span> <span class=\"n\">XRD</span><span class=\"p\">,</span> <span class=\"n\">eld_range</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">50</span><span class=\"p\">,</span><span class=\"mi\">120</span><span class=\"p\">),</span> <span class=\"n\">xrd_range</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">2.0</span><span class=\"p\">,</span><span class=\"mf\">2.5</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (3) Calibration constant from known microscope parameters.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (The four parameters below are usually known for given microscope.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">calibration_constant</span> <span class=\"o\">=</span> \\\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Calculate</span><span class=\"o\">.</span><span class=\"n\">from_microscope_constants</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"n\">voltage_kV</span> <span class=\"o\">=</span> <span class=\"mi\">120</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"n\">camera_length_mm</span> <span class=\"o\">=</span> <span class=\"mi\">170</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"n\">camera_pixel_size_um</span> <span class=\"o\">=</span> <span class=\"mf\">13.2</span><span class=\"p\">,</span> <span class=\"n\">binning</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n"}, {"fullname": "ediff.calibration.Calculate.from_max_peaks", "modulename": "ediff.calibration", "qualname": "Calculate.from_max_peaks", "kind": "function", "doc": "<p>Calibration constant from the <em>maximal</em> peaks on ELD and PXRD profiles.</p>\n\n<ul>\n<li>ELD/XRD profiles represent 1D electron/X-ray diffraction patterns.</li>\n<li>More info about ELD/XRD profiles in EDIFF\n=&gt; see the docs of ediff.io.read_profile function.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>eld_profile</strong> (str or numpy.array):\nThe <em>eld_profile</em> (ELD) is\nan electron diffraction profile in EDIFF format.\nIt can come as file (if <em>eld_profile</em> = str = filename)\nor array (if <em>eld_profile</em> = numpy.array).</li>\n<li><strong>xrd_profile</strong> (str or numpy.array):\nThe <em>xrd_profile</em> (XRD) is\nan X-rayd diffraction profile in EDIFF format.\nIt can come as file (if <em>xrd_profile</em> = str = filename)\nor array (if <em>xrd_profile</em> = numpy.array).</li>\n<li><strong>messages</strong> (bool, optional, default is True):\nIf <em>messages</em> = True,\nprint some information\nand the final calibration constant to stdout.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>calibration constant</strong> (float):\nThe multiplicative constant that converts\nED-profile X-coordinate-in-pixels\nto X-coordinate-in-q-vectors [1/A].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eld_profile</span>, </span><span class=\"param\"><span class=\"n\">xrd_profile</span>, </span><span class=\"param\"><span class=\"n\">messages</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.calibration.Calculate.from_max_peaks_in_range", "modulename": "ediff.calibration", "qualname": "Calculate.from_max_peaks_in_range", "kind": "function", "doc": "<p>Calibration constant from the <em>selected</em> peaks on ED and PXRD profiles.</p>\n\n<ul>\n<li>ELD/XRD profiles represent 1D electron/X-ray diffraction patterns.</li>\n<li>More info about ELD/XRD profiles in EDIFF\n=&gt; see the docs of ediff.io.read_profile function.</li>\n<li>The peaks are selected using arguments <em>eld_range</em> and <em>xrd_range</em>.\n<ul>\n<li>Both arguments are tuples of two floats = x-ranges.</li>\n<li>Only the maximal peaks in given ranges are considered.</li>\n<li>ED range is in [pixels] and PXRD range is given in [q-vectors].</li>\n</ul></li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>eld_profile</strong> (str or numpy.array):\nThe <em>eld_profile</em> is\nan electron diffraction profile in EDIFF format.\nIt can come as file (if <em>eld_profile</em> = str = filename)\nor array (if <em>eld_profile</em> = numpy.array).</li>\n<li><strong>xrd_profile</strong> (str or numpy.array):\nThe <em>xrd_profile</em> is\nan X-rayd diffraction profile in EDIFF format.\nIt can come as file (if <em>xrd_profile</em> = str = filename)\nor array (if <em>xrd_profile</em> = numpy.array).</li>\n<li><strong>eld_range</strong> (tuple of two floats, optional, default is None):\nThe x-range in 1D ED profile,\nin which we should search for the maximal peak.\nThe ED x-range is given in [pixels].</li>\n<li><strong>xrd_range</strong> (tuple of two floats, optional, default is None):\nThe x-range in 1D XRD profile,\nin which we should search for the maximal peak.\nThe XRD x-range is given in [q-vectors].</li>\n<li><strong>messages</strong> (bool, optional, default is True):\nIf <em>messages</em> = True,\nprint some information\nand the final calibration constant to stdout.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>calibration constant</strong> (float):\nThe multiplicative constant that converts\nED-profile X-coordinate-in-pixels\nto X-coordinate-in-q-vectors [1/A].</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>ELD profile = 1D radially averaged\npowder electron diffraction pattern\n<ul>\n<li>in EDIFF, it is obtained from an experimental 2D difractogram</li>\n</ul></li>\n<li>XRD profile = 1D powder X-ray diffraction pattern\n<ul>\n<li>in EDIFF, it is calculated from a standard CIF file\n= Crystallographic Information File</li>\n</ul></li>\n<li>EDIFF format of ELD and XRD profiles employed in EDIFF package\n<ul>\n<li>ELD and XRD profiles can come in the form of files or np.arrays</li>\n<li>Columns in files &lt;=&gt; rows in np.arrays (we use: <em>unpack=True</em>)</li>\n<li>ELD profile = 3 cols = pixels, intensity, bkgr-corrected-intsty</li>\n<li>XRD profile = 4 cols = 2theta[deg], S[1/A], q[1/A], norm-intsty</li>\n</ul></li>\n<li>EDIFF calculation of ELD and XRD profiles is best seen from examples:\n<ul>\n<li><a href=\"https://mirekslouf.github.io/ediff/docs\"><a href=\"https://mirekslouf.github.io/ediff/docs\">https://mirekslouf.github.io/ediff/docs</a></a> -> worked example</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">eld_profile</span>,</span><span class=\"param\">\t<span class=\"n\">xrd_profile</span>,</span><span class=\"param\">\t<span class=\"n\">eld_range</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">xrd_range</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">messages</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.calibration.Calculate.from_microscope_parameters", "modulename": "ediff.calibration", "qualname": "Calculate.from_microscope_parameters", "kind": "function", "doc": "<p>Calibration constant from microscope-specific parameters.</p>\n\n<ul>\n<li>The calibration constant can be estimated from parameters,\nwhich are typical of given microscope + camera system.</li>\n<li>The parameters we need to know are: (i) accelerating_voltage,\n(ii) camera_length, (iii) camera_pixel_size, and (iv) binning.</li>\n<li>Warning: All three parameters may change\nfrom experiment to experiment (although it is not typical);\ndetailed explanation is given below in Technical notes section.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>voltage_kV</strong> (int):\nAccelerating voltage in [kV].</li>\n<li><strong>camera_length_mm</strong> (float):\nCamera lenght in [mm].</li>\n<li><strong>camera_pixel_size_um</strong> (float):\nCamera pixel size in [um].</li>\n<li><strong>binning</strong> (int):\nBinning=1,2,4,... increases camera_pixel_size (1x,2x,4x,...).</li>\n<li><strong>messages</strong> (bool, optional, default is True):\nIf {True}, the function prints outputs to stdnout.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>calibration constant</strong> (float):\nThe multiplicative constant that converts\nED-profile X-coordinate-in-pixels\nto X-coordinate-in-q-vectors [1/A].</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>This calculation is based on four microscope parameters,\nnamely: (i) accelerating_voltage, (ii) camera_length_mm,\n(iii) camera_pixel_size, and (iv) binning.</li>\n<li>Nevertheless, three of the parameters may change\nfrom experiment to experiment:\n<ul>\n<li><em>accelerating_voltage_kV</em> for given TEM\ncan be changed by user (although it is not typical).</li>\n<li><em>camera_length_mm</em> is routinely adjusted\nto see the desired range of difractions;\nthe TEM software usually displays some information\nabout the nominal camera length.</li>\n<li><em>binning</em> averages the neighboring pixels of the camera;\nFor example, the binning=1,2,4,...\nincreases the pixel size 1x,2x,4x,..</li>\n</ul></li>\n<li>IMPORTANT: The nominal camera length\nshown by the microscope (<em>D</em>)\nmay not be the correct camera lenght (<em>camera_length_mm</em>)\nneeded for the calculation.\n<ul>\n<li>Possible reasons: Exact amera position (bottom x upper camera),\nprojective lenses (which may change the magnification\nof the diffraction pattern.</li>\n<li>Real-life solution: we need to know real <em>camera_length_mm</em>\nfor each theoretical/nominal/TEM-software-displayed\ncammera length <em>D</em>!</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">voltage_kV</span>,</span><span class=\"param\">\t<span class=\"n\">camera_length_mm</span>,</span><span class=\"param\">\t<span class=\"n\">camera_pixel_size_um</span>,</span><span class=\"param\">\t<span class=\"n\">binning</span>,</span><span class=\"param\">\t<span class=\"n\">messages</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.calibration.Microscopes", "modulename": "ediff.calibration", "qualname": "Microscopes", "kind": "class", "doc": "<p>A dataclass with functions to <em>determine</em>\nthe calibration constant for <em>the calibrated microscopes</em>.</p>\n\n<p>Usage of the ediff.calibration.Microscopes dataclass functions:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">ediff</span> <span class=\"k\">as</span> <span class=\"nn\">ed</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (1) The simplest case</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (all parameters are at their typical/default values</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (for given microscope/camera combination = Tecnai/Veleta</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (voltage = 120kV, camera_pix_size = 13.2um, binning=2, D=1000mm</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">my_microscope</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Microscopes</span><span class=\"o\">.</span><span class=\"n\">TecnaiVeleta</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">my_microscope</span><span class=\"o\">.</span><span class=\"n\">calibration_constant</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (2) The intermediate case</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (all parameters at their typical/default values, BUT...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (...the nominal camera distance has changed =&gt; D=1000mm =&gt; D=750mm</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">my_microscope</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Microscopes</span><span class=\"o\">.</span><span class=\"n\">TecnaiVeleta</span><span class=\"p\">(</span><span class=\"n\">D</span><span class=\"o\">=</span><span class=\"mi\">750</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">my_microscope</span><span class=\"o\">.</span><span class=\"n\">calibration_constant</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (3) The most complex case</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (all parameters were changed somehow</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">my_microscope</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">calibration</span><span class=\"o\">.</span><span class=\"n\">Microscopes</span><span class=\"o\">.</span><span class=\"n\">TecnaiVeleta</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">D</span><span class=\"o\">=</span><span class=\"mi\">750</span><span class=\"p\">,</span> <span class=\"n\">voltage_kV</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">camera_pixel_size_um</span><span class=\"o\">=</span><span class=\"mf\">13.2</span><span class=\"n\">um</span><span class=\"p\">,</span> <span class=\"n\">binning</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">my_microscope</span><span class=\"o\">.</span><span class=\"n\">calibration_constant</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Technical notes:</p>\n\n<ul>\n<li>Each calibrated {microscope + camera} system\nis defined by one ediff.calibration.Microscopes subclass.</li>\n<li>Example: {Tecnai microscope + Veleta camera}\nis represented by ediff.calibration.Microscopes.TecnaiVeleta subclass.</li>\n<li>The final calculation of the calibration constant is made by the\ngeneral function: ediff.calibration.Calculate.from_microscope_parameters,\nbut in this case the arguments of the function are pre-defined\nwithin each subclass (such as TecnaiVeleta, TecnaiMorada...).</li>\n</ul>\n"}, {"fullname": "ediff.calibration.Microscopes.TecnaiVeleta", "modulename": "ediff.calibration", "qualname": "Microscopes.TecnaiVeleta", "kind": "class", "doc": "<p>The default parameters for\nthe microscope/camera = Tecnai/Veleta3G.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>D</strong> (float, default is 1000):\nThe <em>nominal camera length</em> from the control software.</li>\n<li><strong>D_to_CL_coefficient</strong> (float, default is 1/4.5):\nThe coefficient to convert\n<em>nominal camera lenght</em> to <em>real_camera_length</em>.\nThis coefficient is specific for given system\nas the <em>nominal</em> and <em>real</em> camera length may be different.</li>\n<li><strong>voltage_kV</strong> (float, default is 120):\nThe accelerating voltage, typical of given system.</li>\n<li><strong>camera_pixel_size_um</strong> (float, default is 13.2):\nThe camera pixel size = a constant for given camera.</li>\n<li><strong>binning</strong> (int, default is 2):\nThe binning, which is typical of given system.</li>\n<li><strong>messages</strong> (bool, deafult is True):\nIf True, print additional messages on stdout.</li>\n</ul>\n"}, {"fullname": "ediff.calibration.Microscopes.TecnaiVeleta.calibration_constant", "modulename": "ediff.calibration", "qualname": "Microscopes.TecnaiVeleta.calibration_constant", "kind": "variable", "doc": "<p>The calibration constant for\nthe microscope/camera = Tecnai/Veleta3G.</p>\n\n<ul>\n<li>The constant is calculated from the pre-defined parameters.</li>\n<li>The parameters can be kept/changed during the initialization.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>q_calibration</strong>: The calibration constant,\nwhich converts distances-in-pixels to distances-in-q-vectors.</li>\n</ul>\n\n<h6 id=\"sample-usage\">Sample usage</h6>\n\n<ul>\n<li>See docs of the superclass = ediff.calibration.Microscopes</li>\n</ul>\n"}, {"fullname": "ediff.calibration.Microscopes.TecnaiMorada", "modulename": "ediff.calibration", "qualname": "Microscopes.TecnaiMorada", "kind": "class", "doc": "<p>The default parameters for\nthe microscope/camera = Tecnai/Morada.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>D</strong> (float, default is 660):\nThe <em>nominal camera length</em> from the control software.</li>\n<li><strong>D_to_CL_coefficient</strong> (float, default is 1/4):\nThe coefficient to convert\n<em>nominal camera lenght</em> to <em>real_camera_length</em>.\nThis coefficient is specific for given system\nas the <em>nominal</em> and <em>real</em> camera length may be different.</li>\n<li><strong>voltage_kV</strong> (float, default is 120):\nThe accelerating voltage, typical of given system.</li>\n<li><strong>camera_pixel_size_um</strong> (float, default is 9.0):\nThe camera pixel size = a constant for given camera.</li>\n<li><strong>binning</strong> (int, default is 4):\nThe binning, which is typical of given system.</li>\n<li><strong>messages</strong> (bool, deafult is True):\nIf True, print additional messages on stdout.</li>\n</ul>\n"}, {"fullname": "ediff.calibration.Microscopes.TecnaiMorada.calibration_constant", "modulename": "ediff.calibration", "qualname": "Microscopes.TecnaiMorada.calibration_constant", "kind": "variable", "doc": "<p>The calibration constant for\nthe microscope/camera = Tecnai/Morada.</p>\n\n<ul>\n<li>The constant is calculated from the pre-defined parameters.</li>\n<li>The parameters can be kept/changed during the initialization.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>q_calibration</strong>: The calibration constant,\nwhich converts distances-in-pixels to distances-in-q-vectors.</li>\n</ul>\n\n<h6 id=\"sample-usage\">Sample usage</h6>\n\n<ul>\n<li>See docs of the superclass = ediff.calibration.Microscopes</li>\n</ul>\n"}, {"fullname": "ediff.calibration.Utils", "modulename": "ediff.calibration", "qualname": "Utils", "kind": "class", "doc": "<p>Utilities for the calculation of calibration constants.</p>\n"}, {"fullname": "ediff.calibration.Utils.electron_wavelength", "modulename": "ediff.calibration", "qualname": "Utils.electron_wavelength", "kind": "function", "doc": "<p>Calculate relativistic wavelenght of accelerated electrons.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>U</strong> (float):\nAccelerating voltage [kV].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Lambda</strong> (float):\nRelativistic wavelenght of electrons,\nwhich were accelerated with the voltage <em>U</em>[kV]\nin an electron microscope.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">U</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.calibration.Utils.calc_final_calibration_constants", "modulename": "ediff.calibration", "qualname": "Utils.calc_final_calibration_constants", "kind": "function", "doc": "<p>Calculate final calibration constants\nfrom known CC and camera_pixel_size.</p>\n\n<ul>\n<li>Once we know <em>CC</em>, <em>camera_pixel_size</em>, and <em>binning</em>,\nthe calculation of the final calibration constants\nis surprisingly easy.</li>\n<li>The full justification of the calculation\nis given in the comments of the source code below.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>camera_constant_mmA</strong> (float):\nThe camera constant (from R<em>d = CL</em>Lambda = CC) in [mmA].</li>\n<li><strong>camera_pixel_size_um</strong> (float):\nThe real dimension of one pixel of the camera (detector) in [um].</li>\n<li><strong>binning</strong> (int):\nBinning = 1,2,4,... increases pixel size (1x,2x,4x,...)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>R_calibration, S_calibration, q_calibration</strong> (three floats):\n<ul>\n<li>R_calibration = the camera pixel size in [mm].</li>\n<li>S_calibration = the camera pixel size in S-vector units [1/A].</li>\n<li>q_calibration = the camaera pixel size in q-vector units [1/A].</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">camera_pixel_size_um</span>, </span><span class=\"param\"><span class=\"n\">binning</span>, </span><span class=\"param\"><span class=\"n\">camera_constant_mmA</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.calibration.Utils.print_final_calibration_constants", "modulename": "ediff.calibration", "qualname": "Utils.print_final_calibration_constants", "kind": "function", "doc": "<p>Print all constants employed in calibraton to stdout in nice form.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>Lambda</strong> (float):\nThe relativistic wavelenght of electrons in [A].</li>\n<li><strong>CL</strong> (float):\nThe camera lenght (from R<em>d = CL</em>Lambda) in [mm].</li>\n<li><strong>CC</strong> (float):\nThe camera constant (from R<em>d = CL</em>Lambda = CC) in [mmA].</li>\n<li><strong>R_calibration</strong> (float,):\nThe camera pixel size in [mm].</li>\n<li><strong>S_calibration</strong> (float):\nThe camera pixel size in S-vector units [1/A].</li>\n<li><strong>q_calibration</strong> (TYPE):\nThe camera pixel size in q-vector units [1/A].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The arguments are just nicely printed in stdout.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Lambda</span>, </span><span class=\"param\"><span class=\"n\">CL</span>, </span><span class=\"param\"><span class=\"n\">CC</span>, </span><span class=\"param\"><span class=\"n\">R_calibration</span>, </span><span class=\"param\"><span class=\"n\">S_calibration</span>, </span><span class=\"param\"><span class=\"n\">q_calibration</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.calibration.Utils.calibrate_and_normalize_eld_profile", "modulename": "ediff.calibration", "qualname": "Utils.calibrate_and_normalize_eld_profile", "kind": "function", "doc": "<p>Calibrate and normalize ELD profile (in EDIFF format)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>eld_profile</strong> (numpy.array):\nThe original ELD profile in EDIFF format\n(see also the section <em>Technical notes</em> below).</li>\n<li><strong>calibration_constant</strong> (float):\nThe calibration constant,\nwhich converts distance-in-pixels to distance-in-q-vectors.\nMore info about XRD profiles in EDIFF format\n=&gt; initial description of ediff.calibration module.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>eld_profile</strong> (numpy.array):\nThe calibrated and normalized ELD profile (in EDIFF format).</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<p>For more information about\ncalibration constant and ELD profiles in EDIFF format\nsee the initial description of ediff.calibration module.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eld_profile</span>, </span><span class=\"param\"><span class=\"n\">calibration_constant</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center", "modulename": "ediff.center", "kind": "module", "doc": "<h2 id=\"module-ediffcenter\">Module: ediff.center</h2>\n\n<p>Find the center of a 2D diffraction pattern.</p>\n\n<ul>\n<li>The center determination may be surprisingly tricky in certain cases.</li>\n<li>Nevertheless, the user just calls the CenterLocator class as shown below.</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Example: How to use CenterLocator and get results?</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">ediff</span> <span class=\"k\">as</span> <span class=\"nn\">ed</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">center</span> <span class=\"o\">=</span> <span class=\"n\">ed</span><span class=\"o\">.</span><span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">CenterLocator</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>   <span class=\"n\">input_image</span><span class=\"o\">=</span><span class=\"s1\">&#39;some_diffractogram.png&#39;</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>   <span class=\"n\">determination</span><span class=\"o\">=</span><span class=\"s1\">&#39;intensity&#39;</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>   <span class=\"n\">refinement</span><span class=\"o\">=</span><span class=\"s1\">&#39;sum&#39;</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>   <span class=\"n\">messages</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">final_replot</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Determined center coordinates:&#39;</span><span class=\"p\">,</span> <span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">x1</span><span class=\"p\">,</span> <span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">y1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Refined center coordinates   :&#39;</span><span class=\"p\">,</span> <span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">x2</span><span class=\"p\">,</span> <span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">y2</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n"}, {"fullname": "ediff.center.CenterLocator", "modulename": "ediff.center", "qualname": "CenterLocator", "kind": "class", "doc": "<p>CenterLocator object - determine and refine a diffractogram center.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_image</strong> (str, path, or numpy.array):\nThe input image representing a 2D diffraction pattern, either as a \nfile path or a NumPy array.</li>\n<li><strong>determination</strong> (str or None, optional, default is None):\nThe method used for the initial center determination.\nOptions include:\n<ul>\n<li>'manual': Manual detection - user defines 3 points\non selected diffraction ring.</li>\n<li>'hough': Auto-detection - Hough transform for circle detection.</li>\n<li>'intensity': Auto-detection - intensity center in central region.</li>\n</ul></li>\n<li><strong>refinement</strong> (str or None, optional, default is None):\nThe method used for the final center refinement.\nOptions include:\n<ul>\n<li>'manual': Manual adjustment - user adjust the position\nof the selected diffration ring.</li>\n<li>'sum': Auto-refinement - find a diffraction ring\nwith maximal sum of intensities.</li>\n<li>'var': Auto-refinement - find a diffraction ring\nwith minimal variance of intensities.</li>\n</ul></li>\n<li><strong>in_file</strong> (str, optional, default is None):\nFilename of the text file\nfor saving the center coordinates.</li>\n<li><strong>out_file</strong> (str, optional, default is None):\nFilename of the text file\nfor loading the previously saved center coordinates.</li>\n<li><strong>heq</strong> (bool, optional, default is False):\nFlag to indicate whether to perform histogram equalization \non the input image.\nThe equalization is done internally,\nthe image on the screen remains unchanged.</li>\n<li><strong>icut</strong> (float, optional, default is None):\nCut-off intensity level for processing the image.</li>\n<li><strong>cmap</strong> (str, optional, default is 'gray'):\nColormap to be used for displaying the image.</li>\n<li><strong>csquare</strong> (int, optional, default is 50):\nSize of the central square,\nwithin which we will search the intensity center.</li>\n<li><strong>cintensity</strong> (float, optional, default is 0.8):\nThreshold intensity\nfor finding the intensity center.\nPixels with a (relative) intensity lower than cintensity are ignored.</li>\n<li><strong>messages</strong> (bool, optional, default is False):\nFlag to enable or disable informational messages during processing.</li>\n<li><strong>print_sums</strong> (bool, optional, default is False):\nIf True, prints the sum of intensity values for the refined circle \nafter each adjustment, relevant only for manual methods of center \ndetermination and refinement.</li>\n<li><strong>final_print</strong> (bool, optional, default is True):\nIf True, print determined and refined coordinates to stdout.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The center coordinates are stored in instance variables\n(x1,y1) for the determined center and\n(x2,y2) for the refined center.\nLook at the initial example at the top of this module\nto see how to use CenterLocator class.</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>The class initializes (and runs) two sub-classes (= processes),\nCenterDetermination and CenterRefinement.</li>\n<li>The two sub-classes/processes are hidden to common user,\naltough they could be run separately.</li>\n</ul>\n"}, {"fullname": "ediff.center.CenterLocator.output", "modulename": "ediff.center", "qualname": "CenterLocator.output", "kind": "function", "doc": "<p>Manage variables that should be send as the output of the center \ndetection. </p>\n\n<p>If there were set parameters detection_method and \ncorrection method during the class initialization, the output will be\ncoordinates x, y of the center detected by the detection_method and \ncoordinates x, y of refined center position by the correction method.</p>\n\n<p>If there was not set the correction_method parameter, the function\noutputs x, y coordinates of the detected center and None, None for\nthe refined coordinates.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>x</strong> (float):\nx-coordinate of the center detected via detection_method</li>\n<li><strong>y</strong> (float):\ny-coordinate of the center detected via detection_method</li>\n<li><strong>xx</strong> (float):\nx-coordinate of the center detected via refinement_method</li>\n<li><strong>yy</strong> (float):\ny-coordinate of the center detected via refinement_method</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.save_results", "modulename": "ediff.center", "qualname": "CenterLocator.save_results", "kind": "function", "doc": "<p>Save the current results to a specified file. The results are formatted \nto four decimal places for clarity.</p>\n\n<p>This method checks if a file path has been provided through \nthe <code>in_file</code> attribute. </p>\n\n<ul>\n<li>If the specified file exists, the method appends the results \n(x1, y1, x2, y2) to the end of the file. </li>\n<li>If the file does not exist, it creates a new file and writes \nthe results to it.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The results are written in the format:\nx1: <value>, y1: <value>\nx2: <value>, y2: <value></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.load_results", "modulename": "ediff.center", "qualname": "CenterLocator.load_results", "kind": "function", "doc": "<p>Load results from a specified text file.</p>\n\n<p>This method reads the coordinates from a text file defined by the \n<code>out_file</code> attribute. It extracts pairs of coordinates (x1, y1) and \n(x2, y2) from each line in the file. The extracted values are stored in \nlists, allowing for the retrieval of multiple results.The most recent \nvalues of x1, y1, x2, and y2 can be stored as instance variables\nfor easy access.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The results are expected to be in the format:\nx1: <value>, y1: <value>\nx2: <value>, y2: <value></li>\n<li>If multiple sets of coordinates are found, they are stored in lists,\nand only the last set can be accessed as instance variables.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.get_circle_pixels", "modulename": "ediff.center", "qualname": "CenterLocator.get_circle_pixels", "kind": "function", "doc": "<p>Get coordinates of pixels defining circle border</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>self.image_path</strong> (str):\ndirect path to a image with diffraction patterns</li>\n<li><strong>xc</strong> (float64):\nx-coordinate of the detected center</li>\n<li><strong>yc</strong> (float64):\ny-coordinate of the detected center</li>\n<li><strong>radius</strong> (float64):\nradius of the detected center</li>\n<li><strong>num_points</strong> (float64):\nnumber of border points. The default is 360</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>x</strong> (array of float64):\nx-coordinates of pixels from circle border</li>\n<li><strong>y</strong> (array of float64):\ny-coordinates of pixels from circle border</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xc</span>, </span><span class=\"param\"><span class=\"n\">yc</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">num_points</span><span class=\"o\">=</span><span class=\"mi\">360</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.intensity_sum", "modulename": "ediff.center", "qualname": "CenterLocator.intensity_sum", "kind": "function", "doc": "<p>Summation of intensity values of pixels of a diffraction pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong> (array of uint8):\nimage from which the diffraction pattern has been detected.</li>\n<li><strong>px</strong> (float64):\nx-coordinate of the center of the diffraction pattern.</li>\n<li><strong>py</strong> (float64):\ny-coordinate of the center of the diffraction pattern.</li>\n<li><strong>pr</strong> (float64):\nradius of the diffraction pattern.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>s</strong> (float64):\nintensity sum</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.intensity_variance", "modulename": "ediff.center", "qualname": "CenterLocator.intensity_variance", "kind": "function", "doc": "<p>Variance of intensity values of pixels of a diffraction pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong> (array of uint8):\nimage from which the diffraction pattern has been detected.</li>\n<li><strong>px</strong> (float64):\nx-coordinate of the center of the diffraction pattern.</li>\n<li><strong>py</strong> (float64):\ny-coordinate of the center of the diffraction pattern.</li>\n<li><strong>pr</strong> (float64):\nradius of the diffraction pattern.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>s</strong> (float64):\nintensity variance</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.convert_coords", "modulename": "ediff.center", "qualname": "CenterLocator.convert_coords", "kind": "function", "doc": "<p>Convert coordinates between numpy and matplotlib systems.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>x : int or float\n    The x-coordinate in the numpy (column index) format.\ny : int or float\n    The y-coordinate in the numpy (row index) format.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple of (int or float, int or float)\n    The converted coordinates in matplotlib format, where:\n    - First element corresponds to y (new x in matplotlib).\n    - Second element corresponds to x (new y in matplotlib).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.visualize_results", "modulename": "ediff.center", "qualname": "CenterLocator.visualize_results", "kind": "function", "doc": "<p>Visualize diffractogram and its center after\ncenter determination + refinement.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>csquare</strong> (int, optional, default is None):\nIf csquare argument is given,\nonly the central square of the diffractogram will be plotted;\nthe size of the central square will be equal to csquare argument.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The output is the image of the diffractogram\nshowing also the central coordinates and refinement ring.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">csquare</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination", "modulename": "ediff.center", "qualname": "CenterDetermination", "kind": "class", "doc": "<p>CenterDetermination object - initial detection of a diffractogram center.</p>\n\n<p>This class is responsible for identifying the center coordinates of \na 2D diffraction pattern image using various detection methods specified \nby the user. It initializes with the input image and other parameters\nthat influence the center detection process.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>parent</strong> (CenterLocator):\nReference to the parent CenterLocator object, allowing access \nto shared attributes and methods.</li>\n<li><strong>input_image</strong> (str, path, or numpy.array):\nThe input image representing a 2D diffraction pattern, provided as \na file path or a NumPy array.</li>\n<li><strong>determination</strong> (str or None, optional, default is None):\nThe method used for the initial center determination.\nOptions include:\n<ul>\n<li>'manual': Manual detection - user defines 3 points\non selected diffraction ring.</li>\n<li>'hough': Auto-detection - Hough transform for circle detection.</li>\n<li>'intensity': Auto-detection - intensity center in central region.</li>\n</ul></li>\n<li><strong>in_file</strong> (str, optional):\nFilename of the text file from which to load previously saved \ncenter coordinates.</li>\n<li><strong>out_file</strong> (str, optional):\nFilename of the text file to which the detected center coordinates \nwill be saved.</li>\n<li><strong>heq</strong> (bool, optional):\nFlag to indicate whether to perform histogram equalization on the \ninput image. Default is False.</li>\n<li><strong>icut</strong> (float, optional):\nCut-off intensity level for processing the image. Default is None.</li>\n<li><strong>cmap</strong> (str, optional):\nColormap to be used for displaying the image. Default is 'gray'.</li>\n<li><strong>csquare</strong> (int, optional):\nSize of the square for processing. Default is 50.</li>\n<li><strong>cintensity</strong> (float, optional):\nThreshold intensity for detecting features in the image. Default is\n0.8.</li>\n<li><strong>messages</strong> (bool, optional):\nFlag to enable or disable informational messages during processing. \nDefault is False.</li>\n<li><strong>print_sums</strong> (bool, optional):\nIf True, prints the sum of intensity values for the detected circle\nafter each adjustment, relevant only for manual detection methods.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The class preprocesses the input image and then applies the specified \ncenter detection method.</li>\n<li>The detected center coordinates are stored in instance variables\n<code>x</code>, <code>y</code>, and <code>r</code>, representing the center's x-coordinate, \ny-coordinate, and radius, respectively.</li>\n</ul>\n"}, {"fullname": "ediff.center.CenterDetermination.preprocess", "modulename": "ediff.center", "qualname": "CenterDetermination.preprocess", "kind": "function", "doc": "<p>FOR AUTOMATIC METHODS OPTIMIZATION AND MORE UNIVERSAL SOLUTIONS\nFunction for input image preprocessing based on the methods \ndefined in the class initialization - self.detection_method, \nself.correction_method.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>preInit</strong> (bool, optional):\nPerform preprocessing of the input image (when using icut or heq). \nThis is called automatically every time, if no preprocessing\nspecified, the detection and refinement will be performed on \noriginal image. The default is 0.</li>\n<li><strong>preHough</strong> (bool, optional):\nPerform preprocessing for automatic detection via Hough transform.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>manu</strong> (NumPy array):\nPre-processed image for the manual detection method</li>\n<li><strong>edges</strong> (array of bool):\nDetected edges via Canny detector for automatic Hough transform</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">preInit</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preHough</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preManual</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preVar</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preSum</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preInt</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.detection_intensity", "modulename": "ediff.center", "qualname": "CenterDetermination.detection_intensity", "kind": "function", "doc": "<p>Find center of intensity/mass of an array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (2D-numpy array):\nThe array, whose intensity center will be determined.</li>\n<li><strong>csquare</strong> (int, optional, default is 20):\nThe size/edge of the square in the (geometrical) center.\nThe intensity center will be searched only within the central square.\nReasons: To avoid other spots/diffractions and\nto minimize the effect of possible intensity assymetry around center.</li>\n<li><strong>cintensity</strong> (float, optional, default is 0.8):\nThe intensity fraction.\nWhen searching the intensity center, we will consider only\npixels with intensity &gt; max.intensity.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xc,yc</strong> (float,float):\nXY-coordinates of the intensity/mass center of the array.\nRound XY-coordinates if you use them for image/array calculations.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">csquare</span>, </span><span class=\"param\"><span class=\"n\">cintensity</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.detection_Hough", "modulename": "ediff.center", "qualname": "CenterDetermination.detection_Hough", "kind": "function", "doc": "<p>Perform Hough transform to detect center of diffraction patterns.\nThis is a method to automatically detect circular diffraction patterns</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>plot_results</strong> (int, binary):\nPlot the pattern determined by pixels selected by the user.\nDefault is 1. To cancel visualization, set plot_results = 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>self.x</strong> (float64):\nx-coordinate of the detected center</li>\n<li><strong>self.y</strong> (float64):\ny-coordinate of the detected center</li>\n<li><strong>self.r</strong> (float64):\nradius of the detected center</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.detection_3points", "modulename": "ediff.center", "qualname": "CenterDetermination.detection_3points", "kind": "function", "doc": "<p>In the input image, select manually 3 points defining a circle using\na key press event \n    - press '1' to select a point</p>\n\n<p>If the user is not satisfied with the point selection, it can be\ndeleted using a key press event:\n    - press '2' to delete the most recent\n    - press '3' to delete the point closest to the cursor</p>\n\n<p>If the user is satisified with the points selected, the rest \nof the program will be executed \n    - press 'd' to proceed &gt;DONE&lt;</p>\n\n<p>Coordinates of the center and radius will be calculated automatically\nusing method self.calculate_circle()</p>\n\n<p>In addition, the user will be able to manually adjust the original\ncenter position by using pre-defined keys.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>plot_results</strong> (int, binary):\nPlot the pattern determined by pixels selected by the user.\nDefault is 1. To cancel visualization, set plot_results = 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>self.x</strong> (float64):\nx-coordinate of the detected center</li>\n<li><strong>self.y</strong> (float64):\ny-coordinate of the detected center</li>\n<li><strong>self.r</strong> (float64):\nradius of the detected center\n(if available, othervise returns None)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.adjustment_3points", "modulename": "ediff.center", "qualname": "CenterDetermination.adjustment_3points", "kind": "function", "doc": "<p>Adjustment of the center position calculated from 3 points.\nInteractive refinement using keys:</p>\n\n<p>The user can change the position of the center of the diffraction\npattern and also the radius of the detected pattern using keys:\n    - left / right / top / down arrows : move left / right / top / down\n    - '+' : increase radius\n    - '-' : decrease radius\n    - 'd' : done, termination of the refinement</p>\n\n<p>If the interactive figure is closed without any modifications,\nthe function returns input variables and the proccess terminates.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>fig</strong> (figure.Figure object):\ninteractive figure in which a diffraction pattern has been\nmanually detected.</li>\n<li><strong>circle</strong> (patches.Circle object):\ncircle defined via 3 points manually delected</li>\n<li><strong>center</strong> (tuple):\ncalculated center of the input circle.</li>\n<li><strong>plot_results</strong> (boolean):\nvisualize results. The default is 1 (plot detected center).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xy</strong> (tuple):\nx,y-coordinates of the center of the diffraction pattern.</li>\n<li><strong>r</strong> (integer):\nradius of the diffraction pattern.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fig</span>, </span><span class=\"param\"><span class=\"n\">circle</span>, </span><span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.calculate_circle", "modulename": "ediff.center", "qualname": "CenterDetermination.calculate_circle", "kind": "function", "doc": "<p>Calculates coordinates of the center and radius of a circle defined via\n3 points determined by the user. Plots the calculated circle, detected \npoints and marks the center.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>plot_results</strong> (int, binary):\nPlot the calculated center and circle. To cancel visualization, \nset plot_results = 0.</li>\n<li><strong>self.coords</strong> (array of float64):\nCoordinates of 3 manually selected points</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>self.x</strong> (float64):\nx-coordinate of the detected center</li>\n<li><strong>self.y</strong> (float64):\ny-coordinate of the detected center</li>\n<li><strong>self.r</strong> (float64):\nradius of the detected center</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">plot_results</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">patches</span><span class=\"o\">.</span><span class=\"n\">Circle</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.get_radius", "modulename": "ediff.center", "qualname": "CenterDetermination.get_radius", "kind": "function", "doc": "<p>Calculate the radius of a circle based on intensity profiles along \nhorizontal and vertical axes.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>im</strong> (np.ndarray):\nThe 2D image array containing the circle.</li>\n<li><strong>x</strong> (float):\nThe x-coordinate of the circle's center.</li>\n<li><strong>y</strong> (float):\nThe y-coordinate of the circle's center.</li>\n<li><strong>disp</strong> (bool, optional):\nIf True, visualizes the detected intensity profiles and peaks \n(default is False).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: The estimated radius of the circle. Defaults to 100 if no valid \nradius is detected.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">im</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">disp</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterDetermination.visualize_center", "modulename": "ediff.center", "qualname": "CenterDetermination.visualize_center", "kind": "function", "doc": "<p>Visualize detected diffraction patterns and mark the center.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tit</strong> (string):\nname of the method used for circle detection</li>\n<li><strong>x</strong> (float64):\nx-coordinate of the detected center</li>\n<li><strong>y</strong> (float64):\ny-coordinate of the detected center</li>\n<li><strong>r</strong> (float64):\nradius of the detected center</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None.</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">r</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterRefinement", "modulename": "ediff.center", "qualname": "CenterRefinement", "kind": "class", "doc": "<p>CenterRefinement object - final refinement of a diffractogram center.</p>\n\n<p>This class is responsible for refining the center coordinates of a \ndiffraction pattern based on the selected refinement method. It \ninitializes with the input image and other parameters that influence \nthe refinement process.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>parent</strong> (CenterLocator):\nReference to the parent CenterLocator object, allowing access to \nshared attributes and methods.</li>\n<li><strong>input_image</strong> (str, path, or numpy.array):\nThe input image representing a 2D diffraction pattern, provided as \na file path or a NumPy array.</li>\n<li><strong>refinement</strong> (str or None, optional, default is None):\nThe method used for the final center refinement.\nOptions include:\n<ul>\n<li>'manual': Manual adjustment - user adjust the position\nof the selected diffration ring.</li>\n<li>'sum': Auto-refinement - find a diffraction ring\nwith maximal sum of intensities.</li>\n<li>'var': Auto-refinement - find a diffraction ring\nwith minimal variance of intensities.</li>\n</ul></li>\n<li><strong>out_file</strong> (str, optional):\nFilename of the text file to which the refined center coordinates \nwill be saved.</li>\n<li><strong>heq</strong> (bool, optional):\nFlag to indicate whether to perform histogram equalization on the\ninput image. Default is False.</li>\n<li><strong>icut</strong> (float, optional):\nCut-off intensity level for processing the image. Default is None.</li>\n<li><strong>cmap</strong> (str, optional):\nColormap to be used for displaying the image. Default is 'gray'.</li>\n<li><strong>messages</strong> (bool, optional):\nFlag to enable or disable informational messages during processing. \nDefault is False.</li>\n<li><strong>print_sums</strong> (bool, optional):\nIf True, prints the sum of intensity values for the refined circle \nafter each adjustment, relevant only for manual refinement methods.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The class refines the detected center coordinates based on the \nspecified refinement method.</li>\n<li>The refined coordinates are stored in instance variables\n<code>xx</code>, <code>yy</code>, and <code>rr</code>, representing the refined center's x-coordinate, \ny-coordinate, and radius, respectively.</li>\n<li>If an unsupported refinement method is specified, the class will print \nan error message and exit.</li>\n</ul>\n"}, {"fullname": "ediff.center.CenterRefinement.ref_interactive", "modulename": "ediff.center", "qualname": "CenterRefinement.ref_interactive", "kind": "function", "doc": "<p>Manual refinement of the detected diffraction pattern via one of \nthe methods provided in the class CircleDetection.</p>\n\n<p>The user can change the position of the center of the diffraction\npattern and also the radius of the detected pattern using keys:\n    - left / right / top / down arrows : move left / right / top / down\n    - '+' : increase radius\n    - '-' : decrease radius\n    - 'b'/'l' : increase/decrease step size\")\n    - 'd' : done, termination of the refinement</p>\n\n<p>If the interactive figure is closed without any modifications,\nthe function returns input variables and the proccess terminates.</p>\n\n<p>The results are shown in a figure when the refinement is successful.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>px</strong> (float64):\nx-coordinate of the center</li>\n<li><strong>py</strong> (float64):\ny-coordinate of the center</li>\n<li><strong>pr</strong> (float64):\nradius of the circular diffraction pattern</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>x</strong> (float64):\nnew x-coordinate of the center</li>\n<li><strong>y</strong> (float64):\nnew y-coordinate of the center</li>\n<li><strong>r</strong> (float64):\nnew radius of the circular diffraction pattern</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterRefinement.ref_var", "modulename": "ediff.center", "qualname": "CenterRefinement.ref_var", "kind": "function", "doc": "<p>Adjust center coordinates of a detected circular diffraction pattern.\nThe center adjustment is based on variance minimization.</p>\n\n<p>The 8-neighbourhood pixels (x) of the current center (o) \nwill be tested regarding the minimization:</p>\n\n<ul>\n<li><p>x x x : (px - dx, py + dy) (px, py + dy) ( px + dx, py + dy)</p></li>\n<li><p>x o x : (px - dx, py)      (px, py)      (px + dx, py)</p></li>\n<li><p>x x x : (px - dx, py - dy) (px, py - dy) (px + dx, py - dy)</p></li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>self.image</strong> (array of uint8):\nInput image in which the diffraction pattern is to be found</li>\n<li><strong>px</strong> (float64):\nx-coordinate of the detected center to be adjusted</li>\n<li><strong>py</strong> (float64):\ny-coordinate of the detected center to be adjusted</li>\n<li><strong>pr</strong> (float64):\nradius of the detected center</li>\n<li><strong>plot_results</strong> (integer (default = 1)):\nPlot Detected center. The default is 1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>px</strong> (array of int32):\ncorrected x-coordinates of pixels from circle border</li>\n<li><strong>py</strong> (array of int32):\ncorrected y-coordinates of pixels from circle border</li>\n<li><strong>pr</strong> (array of int32):\nradius of the detected center</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterRefinement.ref_sum", "modulename": "ediff.center", "qualname": "CenterRefinement.ref_sum", "kind": "function", "doc": "<p>Adjust center position based on gradient optimization method\nvia maximization of intensity sum.</p>\n\n<p>The 8-neighbourhood pixels (x) of the current center (o) \nwill be tested regarding the maximization:</p>\n\n<ul>\n<li><p>x x x : (px - dx, py + dy) (px, py + dy) ( px + dx, py + dy)</p></li>\n<li><p>x o x : (px - dx, py)      (px, py)      (px + dx, py)</p></li>\n<li><p>x x x : (px - dx, py - dy) (px, py - dy) (px + dx, py - dy)</p></li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>px</strong> (float64):\nx-coordinate of the detected center to be adjusted.</li>\n<li><strong>py</strong> (float64):\ny-coordinate of the detected center to be adjusted.</li>\n<li><strong>pr</strong> (float64):\nradius of the detected center.</li>\n<li><strong>plot_results</strong> (int, optional):\nPlot Detected center. \nThe default is 1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<p>best_center[0] : float64\n    Adjusted x-coordinate of the center.\nbest_center[1] : float64\n    Adjusted y-coordinate of the center.\nbest_radius : float64\n    The adjusted radius of the circular diffraction pattern.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.HandlerCircle", "modulename": "ediff.center", "qualname": "HandlerCircle", "kind": "class", "doc": "<p>Helper class for creating circular markers in matplotlib legends.</p>\n\n<p>This class customizes the legend to display circular markers instead of the \ndefault. It is intended for internal use within the module and not \nfor general use.</p>\n\n<h2 id=\"methods\">Methods:</h2>\n\n<p>create_artists(legend, \n               orig_handle, \n               xdescent,\n               ydescent, \n               width, \n               height, \n               fontsize, \n               trans):\n    Creates a circular marker for the legend based on the original handle's \n    properties.</p>\n\n<p>Parameters for <code>create_artists</code>:\n    legend : matplotlib.legend.Legend\n        The legend instance where the custom marker will be used.\n    orig_handle : matplotlib.artist.Artist\n        The original handle containing the marker properties \n        (e.g., facecolor, edgecolor).\n    xdescent : float\n        Horizontal offset adjustment for the marker.\n    ydescent : float\n        Vertical offset adjustment for the marker.\n    width : float\n        Width of the legend entry.\n    height : float\n        Height of the legend entry.\n    fontsize : float\n        Font size of the legend text.\n    trans : matplotlib.transforms.Transform\n        Transformation applied to the marker's coordinates.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>list of matplotlib.patches.Circle\n    A list containing a single circular marker artist.</p>\n", "bases": "matplotlib.legend_handler.HandlerBase"}, {"fullname": "ediff.center.HandlerCircle.create_artists", "modulename": "ediff.center", "qualname": "HandlerCircle.create_artists", "kind": "function", "doc": "<p>Return the legend artists generated.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>legend</strong> (<code>~matplotlib.legend.Legend</code>):\nThe legend for which these legend artists are being created.</li>\n<li><strong>orig_handle</strong> (<code>~matplotlib.artist.Artist</code> or similar):\nThe object for which these legend artists are being created.</li>\n<li><strong>xdescent, ydescent, width, height</strong> (int):\nThe rectangle (<em>xdescent</em>, <em>ydescent</em>, <em>width</em>, <em>height</em>) that the\nlegend artists being created should fit within.</li>\n<li><strong>fontsize</strong> (int):\nThe fontsize in pixels. The legend artists being created should\nbe scaled according to the given fontsize.</li>\n<li><strong>trans</strong> (<code>~matplotlib.transforms.Transform</code>):\nThe transform that is applied to the legend artists being created.\nTypically from unit coordinates in the handler box to screen\ncoordinates.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">legend</span>,</span><span class=\"param\">\t<span class=\"n\">orig_handle</span>,</span><span class=\"param\">\t<span class=\"n\">xdescent</span>,</span><span class=\"param\">\t<span class=\"n\">ydescent</span>,</span><span class=\"param\">\t<span class=\"n\">width</span>,</span><span class=\"param\">\t<span class=\"n\">height</span>,</span><span class=\"param\">\t<span class=\"n\">fontsize</span>,</span><span class=\"param\">\t<span class=\"n\">trans</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.IntensityCenter", "modulename": "ediff.center", "qualname": "IntensityCenter", "kind": "class", "doc": "<p>Simple center determination for a symmetric diffractogram.</p>\n\n<ul>\n<li>The center is determined as a center of intensity.</li>\n<li>This works well for simple, symmetric diffraction patters, which are:\n(i) without beamstopper, (ii) pre-centered, and (iii) powder-like.</li>\n<li>A real-life example of a simple symmetric diffractogram:\na good powder electron diffraction pattern from STEMDIFF software.</li>\n<li>This class is a legacy from previous EDIFF versions;\nit is kept mostly for backward compatibility.\nThe functions in this class can be (and should be)\nreplaced by a simple call of ediff.center.CenterLocator object.</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Center determination in a simple symmetric diffraction pattern</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (center = just center_of_intensity, no refinement</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (1) Old way = this (old, legacy) IntensityCenter class:</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xc</span><span class=\"p\">,</span><span class=\"n\">yc</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">IntensityCenter</span><span class=\"o\">.</span><span class=\"n\">center_of_intensity</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">arr</span><span class=\"p\">,</span> <span class=\"n\">csquare</span><span class=\"o\">=</span><span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"n\">cintensity</span><span class=\"o\">=</span><span class=\"mf\">0.8</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (2) New way = newer (and more universal) CenterLocator class:</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xc</span><span class=\"p\">,</span><span class=\"n\">yc</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">CenterLocator</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">arr</span><span class=\"p\">,</span> <span class=\"n\">detection_method</span><span class=\"o\">=</span><span class=\"s1\">&#39;intensity&#39;</span><span class=\"p\">,</span> <span class=\"n\">csquare</span><span class=\"o\">=</span><span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"n\">cintensity</span><span class=\"o\">=</span><span class=\"mf\">0.8</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n"}, {"fullname": "ediff.center.IntensityCenter.center_of_intensity", "modulename": "ediff.center", "qualname": "IntensityCenter.center_of_intensity", "kind": "function", "doc": "<p>Find center of intensity/mass of an array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (2D-numpy array):\nThe array, whose intensity center will be determined.</li>\n<li><strong>csquare</strong> (int, optional, default is 20):\nThe size/edge of the square in the (geometrical) center.\nThe intensity center is searched only within the central square.\nReasons: To avoid other spots/diffractions and\nto minimize the effect of an intensity assymetry around center.</li>\n<li><strong>cintensity</strong> (float, optional, default is 0.8):\nThe intensity fraction.\nWhen searching the intensity center, we will consider only\npixels with intensity &gt; max.intensity.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xc,yc</strong> (float,float):\nXY-coordinates of the intensity/mass center of the array.\nRound XY-coordinates if you use them for image/array calculations.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">csquare</span><span class=\"o\">=</span><span class=\"mi\">20</span>, </span><span class=\"param\"><span class=\"n\">cintensity</span><span class=\"o\">=</span><span class=\"mf\">0.8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io", "modulename": "ediff.io", "kind": "module", "doc": "<h2 id=\"module-ediffio\">Module: ediff.io</h2>\n\n<p>Input/output functions for package EDIFF.</p>\n"}, {"fullname": "ediff.io.read_image", "modulename": "ediff.io", "qualname": "read_image", "kind": "function", "doc": "<p>Read grayscale image into 2D numpy array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_name</strong> (string or pathlib object):\nName of image that should read into numpy 2D array.</li>\n<li><strong>itype</strong> (string ('8bit'  or '16bit')):\nType of the image: 8 or 16 bit grayscale</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>arr</strong> (2D numpy array):\nThe <em>arr</em> is the input image read to an array by means of numpy.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">image_name</span>, </span><span class=\"param\"><span class=\"n\">itype</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.read_profile", "modulename": "ediff.io", "qualname": "read_profile", "kind": "function", "doc": "<p>Read the ELD or XRD profile in EDIFF format.</p>\n\n<ul>\n<li>More info about ELD/XRD profiles in EDIFF\n=&gt; see the section <em>Technical notes</em> below.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>profile</strong> (str or numpy.array):\n<ul>\n<li>If profile = str,\nwe assume a filename\nof the file with ELD or XRD profile in EDIFF format.</li>\n<li>If profile = numpy.array,\nwe assume a 2D-array\ncontaining ELD or XRD profile in EDIFF format.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>profile</strong> (2D numpy.array):\nThe array representing ELD or XRD profile in EDIFF format.\nSee section <em>Technical notes</em> below\nfor explanation of the EDIFF format of the ELD and XRD profiles.</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>ELD profile = 1D radially averaged\npowder electron diffraction pattern\n<ul>\n<li>in EDIFF, it is obtained from an experimental 2D difractogram</li>\n</ul></li>\n<li>XRD profile = 1D powder X-ray diffraction pattern\n<ul>\n<li>in EDIFF, it is calculated from a standard CIF file\n= Crystallographic Information File</li>\n</ul></li>\n<li>EDIFF format of ELD and XRD profiles employed in EDIFF package\n<ul>\n<li>ELD and XRD profiles can come in the form of files or np.arrays</li>\n<li>Columns in files &lt;=&gt; rows in np.arrays (we use: <em>unpack=True</em>)</li>\n<li>ELD profile = 3 cols = pixels, intensity, bkgr-corrected-intsty</li>\n<li>XRD profile = 4 cols = 2theta[deg], S[1/A], q[1/A], norm-intsty</li>\n</ul></li>\n<li>EDIFF calculation of ELD and XRD profiles is best seen from examples:\n<ul>\n<li><a href=\"https://mirekslouf.github.io/ediff/docs\"><a href=\"https://mirekslouf.github.io/ediff/docs\">https://mirekslouf.github.io/ediff/docs</a></a> -> worked example</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">profile</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.set_plot_parameters", "modulename": "ediff.io", "qualname": "set_plot_parameters", "kind": "function", "doc": "<p>Set global plot parameters (mostly for plotting in Jupyter).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>size</strong> (tuple of two floats, optional, the default is (8,6)):\nSize of the figure (width, height) in [cm].</li>\n<li><strong>dpi</strong> (int, optional, the defalut is 100):\nDPI of the figure.</li>\n<li><strong>fontsize</strong> (int, optional, the default is 8):\nSize of the font used in figure labels etc.</li>\n<li><strong>my_defaults</strong> (bool, optional, default is True):\nIf True, some reasonable additional defaults are set,\nnamely line widths and formats.</li>\n<li><strong>my_rcParams</strong> (dict, optional, default is None):\nDictionary in plt.rcParams format\ncontaining any other allowed global plot parameters.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The result is a modification of the global plt.rcParams variable.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">)</span>, </span><span class=\"param\"><span class=\"n\">dpi</span><span class=\"o\">=</span><span class=\"mi\">100</span>, </span><span class=\"param\"><span class=\"n\">fontsize</span><span class=\"o\">=</span><span class=\"mi\">8</span>, </span><span class=\"param\"><span class=\"n\">my_defaults</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">my_rcParams</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.plot_1d_profile", "modulename": "ediff.io", "qualname": "plot_1d_profile", "kind": "function", "doc": "<p>Plot a 1D profile in a simple and stadnard way.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>Xvalues</strong> (array or list-like object):\nX values for plotting.</li>\n<li><strong>Yvalues</strong> (array or list-like object):\nY values for plotting.</li>\n<li><strong>Xlabel</strong> (str):\nLabel of the X-axis.</li>\n<li><strong>Ylabel</strong> (str):\nLabel of the Y-axis.</li>\n<li><strong>Xrange</strong> (list/tuple of two floats):\nX range = minimum and maximu for Xvalues to plot.</li>\n<li><strong>Yrange</strong> (list/tuple of two floats):\nY range = minimum and maximu for Yvalues to plot.</li>\n<li><strong>title</strong> (str, optional, default is None):\nThe title of the plot.</li>\n<li><strong>output_file</strong> (str, optional, default is None):\nName of the output file.\nIf the argument is not None, the plot is saved to <em>output_file</em>.</li>\n<li><strong>output_file_dpi</strong> (int, optional, default is 300):\nResolution of the output file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The plot is shown in the stdout\nand saved to <em>output_file</em> if requested.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">Xvalues</span>,</span><span class=\"param\">\t<span class=\"n\">Yvalues</span>,</span><span class=\"param\">\t<span class=\"n\">Xlabel</span>,</span><span class=\"param\">\t<span class=\"n\">Ylabel</span>,</span><span class=\"param\">\t<span class=\"n\">Xrange</span>,</span><span class=\"param\">\t<span class=\"n\">Yrange</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_file_dpi</span><span class=\"o\">=</span><span class=\"mi\">300</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.plot_2d_diffractogram", "modulename": "ediff.io", "qualname": "plot_2d_diffractogram", "kind": "function", "doc": "<p>Plot 2D diffraction pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>diffractogram</strong> (numpy.array):\nA numpy.array object representing a 2D diffractogram image.\nIn EDIFF,\nthis array is usually obtained by ediff.ioi.read_image function.</li>\n<li><strong>icut</strong> (integer, optional, default is None):\nUpper limit of intensity shown in the diffractogram.\nThe argument <em>icut</em> is used as <em>vmax</em> in plt.imshow function.\nExample: If <em>icut</em>=300, then all intensities &gt;300 are set to 300.</li>\n<li><strong>title</strong> (str, optional, default is None):\nIf given, then it is the title of the plot.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The 2D diffractogram is just shown in the stdout.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">diffractogram</span>, </span><span class=\"param\"><span class=\"n\">icut</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.plot_final_eld_and_xrd", "modulename": "ediff.io", "qualname": "plot_final_eld_and_xrd", "kind": "function", "doc": "<p>Final plot/comparison of ELD and XRD profiles.</p>\n\n<ul>\n<li>During the final plotting, we fine-tune the ELD calibration.</li>\n<li>This is done by iterative modification of fine_tuning constant.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>eld_profile</strong> (str or numpy.array):\nThe <em>eld_profile</em> (ELD) is\nan electron diffraction profile in EDIFF format.\nIt can come as file (if <em>eld_profile</em> = str = filename)\nor array (if <em>eld_profile</em> = numpy.array).\nMore info about ELD profiles in EDIFF\n=&gt; see docs of ediff.calibration.Calculate.from_max_peaks function.</li>\n<li><strong>xrd_profile</strong> (str or numpy.array):\nThe <em>xrd_profile</em> (XRD) is\nan X-rayd diffraction profile in EDIFF format.\nIt can come as file (if <em>xrd_profile</em> = str = filename)\nor array (if <em>xrd_profile</em> = numpy.array).\nMore info about XRD profiles in EDIFF\n=&gt; see docs of ediff.calibration.Calculate.from_max_peaks function.</li>\n<li><strong>fine_tuning</strong> (float):\nThe constant for the final fine-tuning of peak position.\nThe <em>fine_tuning</em> constant has a starting value of 1.000.\nIf ELD and XRD peaks are shifted, the constant should be adjusted.\nThe constant multiplies the X-values of ELD profile.</li>\n<li><strong>x_range</strong> (tuple of two floats):\nThe limits for X-axis (minimum and maximu q-vectors on X-axis).</li>\n<li><strong>eld_data_label</strong> (str, optional, default is 'ED experiment'):\nThe label of ELD data (= name of the electron diffraction data).</li>\n<li><strong>xrd_data_label</strong> (str, optional, the default is 'XRD calculation'):\nThe label of XRD data (= name of the X-ray diffraction data).</li>\n<li><strong>x_axis_label</strong> (str, optional, the default is '$q$ [1/\u212b]' ~ q [1/A]):\nThe label of X-axis.</li>\n<li><strong>y_axis_label</strong> (str, optiona, the default is 'Intensity'.):\nThe label of Y-axis.</li>\n<li><strong>xticks</strong> (float, optional, default is None):\nThe X-axis ticks (if not omitted, use the default).</li>\n<li><strong>yticks</strong> (float, optional, default is None):\nThe Y-axis ticks (if not omitted, use the default).</li>\n<li><strong>mxticks</strong> (float, optional, default is None):\nThe Y-axis minor ticks (if not omitted, use the default).</li>\n<li><strong>myticks</strong> (float, optional, default is None):\nThe Y-axis minor ticks (if not omitted, use the default).</li>\n<li><strong>output_file</strong> (str, optional, default is None):\nThe filename, to which the final graph should be saved.\nIf <em>output_file</em> is not None (= the default),\nthe plot is not only shown in stdout,\nbut also saved in the <em>output_file</em>.</li>\n<li><strong>output_file_dpi</strong> (int, optional, default is 300):\nThe DPI of the output graph.</li>\n<li><strong>transparent</strong> (bool, optional, default is False):\nIf <em>transparent</em> = True, then the image background is transparent.</li>\n<li><strong>CLI</strong> (bool, optional, default is False):\nIf <em>CLI</em> = True, we assume command line interface\nand the plot is not shown, just saved.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The plot is shown in the stdout\nand saved to <em>output_file</em> if requested.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">eld_profile</span>,</span><span class=\"param\">\t<span class=\"n\">xrd_profile</span>,</span><span class=\"param\">\t<span class=\"n\">fine_tuning</span>,</span><span class=\"param\">\t<span class=\"n\">x_range</span>,</span><span class=\"param\">\t<span class=\"n\">eld_data_label</span><span class=\"o\">=</span><span class=\"s1\">&#39;ED experiment&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">xrd_data_label</span><span class=\"o\">=</span><span class=\"s1\">&#39;XRD calculation&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">x_axis_label</span><span class=\"o\">=</span><span class=\"s1\">&#39;$q$ [1/\u212b]&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">y_axis_label</span><span class=\"o\">=</span><span class=\"s1\">&#39;Intensity&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">xticks</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">yticks</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">mxticks</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">myticks</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_file_dpi</span><span class=\"o\">=</span><span class=\"mi\">300</span>,</span><span class=\"param\">\t<span class=\"n\">transparent</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">CLI</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.plot_radial_distributions", "modulename": "ediff.io", "qualname": "plot_radial_distributions", "kind": "function", "doc": "<p>Plot one or more 1D-radial distrubution files in one graph.</p>\n\n<ul>\n<li>This is a rather specific function.</li>\n<li>It is employed mostly when we combine STEMDIFF and EDIFF.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_to_plot</strong> (2D-list):\n<ul>\n<li>list with several rows containing [data, linestyle, label]</li>\n<li>data = data for plotting - they can be one of the following:\n<ul>\n<li>PNG filename = str, a PNG-file = 2D diffraction pattern</li>\n<li>TXT filename = str, a text file = 1D diffraction profile</li>\n<li>2D-array = a numpy array, containg 2D diffraction pattern</li>\n<li>1D-array = a numpy array, containing 1D diffraction profile</li>\n<li>Note1: 2D-pattern = a square image/array with intensities</li>\n<li>Note2: 1D-profile = a text file/array with two cols/rows = [R,I],\nwhere R = distance from center, I = diffraction intensity</li>\n</ul></li>\n<li>linestyle = matplotlib.pyplot format, such as 'r-' (red line)</li>\n<li>label = name of the data, which will appear in the plot legend</li>\n</ul></li>\n<li><strong>xlimit</strong> (int):\nmaximum of the X-axis</li>\n<li><strong>ylimit</strong> (int):\nmaximum of the Y-axis</li>\n<li><strong>output_file</strong> (int, optional, default=None):\nName of the output file;\nif the <em>output</em> argument is given,\nthe plot is not only shown on screen, but also saved in <em>output</em> file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The plot is shown in the stdout\nand saved to <em>output_file</em> if requested.</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>This function is quite flexible.</li>\n<li>It can plot one radial distribution or more.</li>\n<li>It can take data from PNG-files, TXT-files, 2D-arrays and 1D-arrays.</li>\n<li>If the input is a PNG-file or2D-array,\nthe center is just <em>estimated</em> as as the center of intensity;\ntherefore, this works only for good diffractograms with a central spot.</li>\n<li>This makes the code a more complex, but it is convenient for the user.</li>\n<li>An example of fast comparison of three 1D-distributions\ntaken from three 2D-diffractograms in the form of 16-bit PNG images:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">plot_radial_distributions</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">data_to_plot</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"p\">[</span><span class=\"s1\">&#39;sum_all_16bit.png&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;k:&#39;</span><span class=\"p\">,</span>  <span class=\"s1\">&#39;All data&#39;</span><span class=\"p\">],</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"p\">[</span><span class=\"s1\">&#39;sum_f_16bit.png&#39;</span><span class=\"p\">,</span>   <span class=\"s1\">&#39;b--&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;F data&#39;</span><span class=\"p\">],</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"p\">[</span><span class=\"s1\">&#39;sum_fd_16bit.png&#39;</span><span class=\"p\">,</span>  <span class=\"s1\">&#39;r-&#39;</span><span class=\"p\">,</span>  <span class=\"s1\">&#39;FD data&#39;</span><span class=\"p\">]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">xlimit</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"n\">ylimit</span><span class=\"o\">=</span><span class=\"mi\">300</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"s1\">&#39;sums_final_1d.png&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_to_plot</span>, </span><span class=\"param\"><span class=\"n\">xlimit</span>, </span><span class=\"param\"><span class=\"n\">ylimit</span>, </span><span class=\"param\"><span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd", "modulename": "ediff.pxrd", "kind": "module", "doc": "<h2 id=\"module-ediffpxrd\">Module: ediff.pxrd</h2>\n\n<p>Calculation of powder X-ray diffraction patterns.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># EDIFF/PXRD module ::calculate diffraction pattern of NaCl</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">ediff.pxrd</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># [0] Crystal structure is defined</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># by means of CIF = Crystallographic Information File.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># CIFs can be downloaded from: https://www.crystallography.net</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">CIF_FILE</span> <span class=\"o\">=</span> <span class=\"sa\">r</span><span class=\"s1\">&#39;./nacl_1000041.cif.cif&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># [1] Crystal, experimental and plot parameters</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># are defined as objects XTAL, EPAR, PPAR and CALC, respectively.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">XTAL</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">pxrd</span><span class=\"o\">.</span><span class=\"n\">Crystal</span><span class=\"p\">(</span><span class=\"n\">structure</span><span class=\"o\">=</span><span class=\"n\">CIF_FILE</span><span class=\"p\">,</span> <span class=\"n\">temp_factors</span><span class=\"o\">=</span><span class=\"mf\">0.8</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EPAR</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">pxrd</span><span class=\"o\">.</span><span class=\"n\">Experiment</span><span class=\"p\">(</span><span class=\"n\">wavelength</span><span class=\"o\">=</span><span class=\"mf\">0.71</span><span class=\"p\">,</span> <span class=\"n\">two_theta_range</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">120</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">PPAR</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">pxrd</span><span class=\"o\">.</span><span class=\"n\">PlotParameters</span><span class=\"p\">(</span><span class=\"n\">x_axis</span><span class=\"o\">=</span><span class=\"s1\">&#39;q&#39;</span><span class=\"p\">,</span> <span class=\"n\">xlim</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">10</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># [2] PXRDcalculation object</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># calculates PXRD during initialization</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># and contains the results for further processing.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">CALC</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">pxrd</span><span class=\"o\">.</span><span class=\"n\">PXRDcalculation</span><span class=\"p\">(</span><span class=\"n\">XTAL</span><span class=\"p\">,</span> <span class=\"n\">EPAR</span><span class=\"p\">,</span> <span class=\"n\">PPAR</span><span class=\"p\">,</span> <span class=\"n\">peak_profile_sigma</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># [3] Show/save CALCulation results.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (it is quite ok to use default settings</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (for more advanced plotting you can use the saved results + arbitrary SW</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">CALC</span><span class=\"o\">.</span><span class=\"n\">print_diffractions</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">CALC</span><span class=\"o\">.</span><span class=\"n\">save_diffractions</span><span class=\"p\">(</span><span class=\"s1\">&#39;nacl_pxrd.py.diff&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">CALC</span><span class=\"o\">.</span><span class=\"n\">plot_diffractogram</span><span class=\"p\">(</span><span class=\"s1\">&#39;nacl_pxrd.py.png&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">CALC</span><span class=\"o\">.</span><span class=\"n\">save_diffractogram</span><span class=\"p\">(</span><span class=\"s1\">&#39;nacl_pxrd.py.txt&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n"}, {"fullname": "ediff.pxrd.Crystal", "modulename": "ediff.pxrd", "qualname": "Crystal", "kind": "class", "doc": "<p>Define crystal structure.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>structure</strong> (structure object):\n<ul>\n<li>The <em>structure object</em> is usually obtained from a CIF-file\n(CIF = Crystallographic Information File).</li>\n<li>The <em>CIF files</em> are available in crystallographic databases,\nsuch as <a href=\"http://www.crystallography.net\"><a href=\"http://www.crystallography.net\">http://www.crystallography.net</a></a></li>\n<li>The exact type of the object is <em>pymatgen.core.structure.Structure</em>\n<ul>\n<li>This indicates that the structure is read from CIF by means of\npymatgen package (which works behind the sceenes).</li>\n<li>This also means that the structure can be created by any\nother way available in pymatgen <a href=\"https://pymatgen.org/\"><a href=\"https://pymatgen.org/\"><a href=\"https://pymatgen.org/\">https://pymatgen.org/</a></a></a></li>\n<li>Nevertheless, for common usage it is enough to\nread the structure from CIF, ignoring technical details.</li>\n</ul></li>\n</ul></li>\n<li><strong>temp_factors</strong> (float or dictionary, optional, the default is 0.8):\n<ul>\n<li>Temperature factors characterize thermal movement of atoms.</li>\n<li>If a float value is given,\nall elements have this temperature factor value.</li>\n<li>If a dictionary is given,\nthe elements have the values defined in the dictionary;\na sample input dictionary: <code>temp_factors = {'Na':1.2, 'Cl':1.1}</code>.</li>\n</ul></li>\n</ul>\n"}, {"fullname": "ediff.pxrd.Crystal.__init__", "modulename": "ediff.pxrd", "qualname": "Crystal.__init__", "kind": "function", "doc": "<ul>\n<li>Initialize Crystal object.</li>\n<li>The parameters are described above in class definition.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">structure</span>, </span><span class=\"param\"><span class=\"n\">temp_factors</span><span class=\"o\">=</span><span class=\"mf\">0.8</span></span>)</span>"}, {"fullname": "ediff.pxrd.Crystal.read_structure_from_CIF", "modulename": "ediff.pxrd", "qualname": "Crystal.read_structure_from_CIF", "kind": "function", "doc": "<p>Read crystall structure from CIF file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>CIF</strong> (str or path object):\n<ul>\n<li>The filename of CIF file.</li>\n<li>CIF = Crystallographic Information File\ncontains information about crystal structure.</li>\n<li>CIF files are usually obtained from crystallographic databases,\nsuch as <a href=\"http://www.crystallography.net\"><a href=\"http://www.crystallography.net\">http://www.crystallography.net</a></a></li>\n</ul></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>structure</strong> (structure object):\n<ul>\n<li>The exact type of the object is\n<em>pymatgen.core.structure.Structure</em>.</li>\n<li>Nevertheless, in the structure objects are usually\ncreated from CIF files (pymatgen is hidden for a common user).</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">CIF</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.Crystal.get_elements", "modulename": "ediff.pxrd", "qualname": "Crystal.get_elements", "kind": "function", "doc": "<p>Get a list of all elements, which are contained in given structure.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>structure</strong> (structure object):\nTypically, the structure objects are\ncreated by function <em>read_structure_from_CIF</em> above.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>list_of_elements</strong> (list):\nList with symbols of all elements\nthat are present in given <em>structure</em>.</li>\n</ul>\n\n<h6 id=\"technical-note\">Technical note</h6>\n\n<ul>\n<li>The elements are obtained from <em>structure</em> object.</li>\n<li>The structure object = pymatgen.core.structure.Structure.</li>\n<li>The list of element names si obtained by a set of tricks\nspecific to pymatgen-structure object.</li>\n<li>These tricks were revealed by inspecting the original\npymatgen.core.structure.Structure in Spyder,\nby means of shortcuts Ctrl+I (help) and Ctrl+G (go to code).</li>\n<li>Common users do not have to use this function.</li>\n<li>The function is just used internally, when setting\ntemperature factors of the elements contained in given <em>structure</em>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">structure</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.Crystal.get_elements_with_temp_factors", "modulename": "ediff.pxrd", "qualname": "Crystal.get_elements_with_temp_factors", "kind": "function", "doc": "<p>Get a dictionary, which contains symbols and temperature factors\nof all elements, which are present in given structure.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>structure</strong> (structure object):\nTypically, the structure objects are\ncreated by function <em>read_structure_from_CIF</em> above.</li>\n<li><strong>B</strong> (float, optional, the default is 0.8):</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>elements_with_temp_factors</strong> (dict):\nDictionary with symbols and temperature factors\nof all elements, which are present in given <em>structure</em>.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The dictionary is in the format required by pymatgen package.</li>\n<li>The pymatgen package is used for PXRD calculations,\nbut these calculations are hidden from common users.</li>\n<li>Common users do not use this function.</li>\n<li>The function is just used internally, when setting\ntemperature factors of the elements contained in given <em>structure</em>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">structure</span>, </span><span class=\"param\"><span class=\"n\">B</span><span class=\"o\">=</span><span class=\"mf\">0.8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.Experiment", "modulename": "ediff.pxrd", "qualname": "Experiment", "kind": "class", "doc": "<p>Define experimental parameters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>wavelength</strong> (float):\nWavelength of the X-rays.\nTypical values are 1.54 A (CuKa) or 0.71 A (MoKa).</li>\n<li><strong>two_theta_range</strong> (list/tuple of two floats):\nMinimal and maximal diffraction angle;\nboth values are TwoTheta angle in [deg] (for given <em>wavelength</em>).</li>\n</ul>\n"}, {"fullname": "ediff.pxrd.Experiment.__init__", "modulename": "ediff.pxrd", "qualname": "Experiment.__init__", "kind": "function", "doc": "<ul>\n<li>Initialize Experimental object.</li>\n<li>The parameters are described above in class definition.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">wavelength</span>, </span><span class=\"param\"><span class=\"n\">two_theta_range</span></span>)</span>"}, {"fullname": "ediff.pxrd.PlotParameters", "modulename": "ediff.pxrd", "qualname": "PlotParameters", "kind": "class", "doc": "<p>Define local+global parameters for plotting.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>title</strong> (str):\nTitle of the plot.</li>\n<li><strong>x_axis</strong> (str, 'TwoTheta','S','q' or 'dhkl', optional, default is 'q'):\nQuantity for X-axis.</li>\n<li><strong>rcParams</strong> (dict; optional, the default is empty dictionary {}):\nThe dictionary should have the format of mathplotlib.pyplot.rcParams.\nThe argmument is passed to matplotlib.pyplot.rcParams.update.\nThis enables to override current rcParams, if necessary.</li>\n</ul>\n"}, {"fullname": "ediff.pxrd.PlotParameters.__init__", "modulename": "ediff.pxrd", "qualname": "PlotParameters.__init__", "kind": "function", "doc": "<ul>\n<li>Initialize PlotParameters object.</li>\n<li>The parameters are described above in class definition.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">x_axis</span><span class=\"o\">=</span><span class=\"s1\">&#39;q&#39;</span>, </span><span class=\"param\"><span class=\"n\">xlim</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">rcParams</span><span class=\"o\">=</span><span class=\"p\">{}</span></span>)</span>"}, {"fullname": "ediff.pxrd.PeakProfiles", "modulename": "ediff.pxrd", "qualname": "PeakProfiles", "kind": "class", "doc": "<p>Define profile of diffraction peaks.</p>\n\n<ul>\n<li>This class is employed only as a namespace.</li>\n<li>It contains three functions/definitions of diffratction peak profiles.</li>\n</ul>\n"}, {"fullname": "ediff.pxrd.PeakProfiles.gaussian", "modulename": "ediff.pxrd", "qualname": "PeakProfiles.gaussian", "kind": "function", "doc": "<p>Gaussian function (~ profile for PXRD calculation).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (numpy array):\nX-variable of Gaussian function.</li>\n<li><strong>m</strong> (float):\nMean value = the center of Gaussian function.</li>\n<li><strong>s</strong> (float):\nStandard deviation = the width of Gaussian function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>NumPy array</strong>: The array with Y-values of the function; Y = Gaussian(X).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PeakProfiles.lorentzian", "modulename": "ediff.pxrd", "qualname": "PeakProfiles.lorentzian", "kind": "function", "doc": "<p>Lorentzian function (~ profile for PXRD calculation).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (numpy array):\nX-variable of Lorentzian function.</li>\n<li><strong>m</strong> (float):\nMean value = the center of Lorentzian function.</li>\n<li><strong>s</strong> (float):\nStandard deviation = the width of Lorentzian function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>NumPy array</strong>: The array with Y-values of the functin; Y = Lorenzian(X).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PeakProfiles.pseudo_voigt", "modulename": "ediff.pxrd", "qualname": "PeakProfiles.pseudo_voigt", "kind": "function", "doc": "<p>Pseudo-Voigt function (~ profile for PXRD calculation).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (numpy array):\nX-variable of pseudo-Voigt function.</li>\n<li><strong>m</strong> (float):\nMean value = the center of pseudo-Voigt function.</li>\n<li><strong>s</strong> (float):\nStandard deviation = the width of pseudo-Voigt function.</li>\n<li><strong>n</strong> (float, optional, the default is 0.5):\nRatio between Gaussian and Lorentzian components.\nIn the very first approximation, we can set n = 0.5.\nFor more details, see <em>Notes</em> subsection below.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>NumPy array</strong>: The array with Y-values of the functin; Y = Lorenzian(X).</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>Pseudo-Voigt function\n= linear combination of Gaussian and Lorentzian function.</li>\n<li>In the 1st approximation:\n<ul>\n<li>50/50 combination =&gt; n = 0.5</li>\n<li>sg = sigma_Gaussian\ndefined so that sg and s yielded the same FWHM</li>\n</ul></li>\n<li>more details in:\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Voigt_profile\"><a href=\"https://en.wikipedia.org/wiki/Voigt_profile\">https://en.wikipedia.org/wiki/Voigt_profile</a></a></li>\n<li><a href=\"https://lmfit.github.io/lmfit-py/builtin_models.html\"><a href=\"https://lmfit.github.io/lmfit-py/builtin_models.html\">https://lmfit.github.io/lmfit-py/builtin_models.html</a></a></li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">s</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mf\">0.5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation", "kind": "class", "doc": "<p>Define calculation of PXRD = powder X-ray diffraction pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>crystal</strong> (ediff.pxrd.Crystal object):\nThis object is usually prepared in advance\nas an instance of ediff.pxrd.Crystal class.</li>\n<li><strong>experiment</strong> (ediff.pxrd.Experiment object):\nThis object is usually prepared in advance\nas an instance of ediff.pxrd.Experiment class.</li>\n<li><strong>plot_parameters</strong> (ediff.pxrd.PlotParameters object):\nThis object is usually prepared in advance\nas an instance of ediff.pxrd.PlotParameters class.</li>\n<li><strong>peak_profile_sigma</strong> (float, optional, the default is 0.03):\nWidth of the calculated diffraction peaks.\nThe default = 0.03 is suitable for most of common calculations\nand corresponds to the default in older PowderCell program (n*FWHM=7).\nFor overlapping peaks it may be slightly decreased,\nwhile for more realistic diffractograms it may be slightly increased.</li>\n<li><strong>peak_profile_type</strong> (None or ediff.pxrd.PeakProfiles object, optional):\nProfile of the calculated diffraction peaks.\nThe default is PeakProfiles.pseudo_voigt.\nThis default is suitable for common calculations\nand does not have to be changed (in great majority of cases).</li>\n</ul>\n"}, {"fullname": "ediff.pxrd.PXRDcalculation.__init__", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.__init__", "kind": "function", "doc": "<p>Initialize PXRDcalcualtion object.\nThe parameters are described above in class definition.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">crystal</span>,</span><span class=\"param\">\t<span class=\"n\">experiment</span>,</span><span class=\"param\">\t<span class=\"n\">plot_parameters</span>,</span><span class=\"param\">\t<span class=\"n\">peak_profile_sigma</span><span class=\"o\">=</span><span class=\"mf\">0.03</span>,</span><span class=\"param\">\t<span class=\"n\">peak_profile_type</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">PeakProfiles</span><span class=\"o\">.</span><span class=\"n\">pseudo_voigt</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "ediff.pxrd.PXRDcalculation.print_diffractions", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.print_diffractions", "kind": "function", "doc": "<p>Print the calculated diffractions to stdout.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.save_diffractions", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.save_diffractions", "kind": "function", "doc": "<p>Save the calculated diffractions to <em>output_file</em>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>output_file</strong> (str):\nName of the output file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None; the output is the list of diffractions in the <em>output_file</em>.</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">output_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.plot_diffractions", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.plot_diffractions", "kind": "function", "doc": "<p>Plot the calculated diffractions.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>outfile</strong> (str, optional, the default is none):\nName of the output file.\nIf not given, the plot is just shown, but not saved.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The output is the plot on the screen (and outfile).\nThis function plots just diffraction intensities,\nnot profiles.\nUse ediff.pxrd.plot_diffractions\nfor diffractogram with intensity profiles.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">outfile</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.plot_diffractions_with_indexes", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.plot_diffractions_with_indexes", "kind": "function", "doc": "<p>Plot indexed diffractions.</p>\n\n<ul>\n<li>This function (usually) creates an interactive plot.</li>\n<li><strong>In CLI</strong> (command line) - the plot is interactive automatically.</li>\n<li><strong>In Spyder or Jupyter</strong> - type the following <em>magic commands</em>:\n<ul>\n<li>BEFORE running (switch on the interactive mode): %matplotlib qt</li>\n<li>AFTER running (back to non-interactive mode): %matplotlib inline</li>\n<li>In Spyder, the commands are typed in the Console window.</li>\n<li>In Jupyter, the commands are usually typed in separate cells.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>None</strong>: This function is to be called exclusively \nas method of PXRDcalculation object.\nIf PXRDcalculation is properly initialized,\nadditional parameters are not needed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The output is the plot in the screen.\nIn a typical case, the plot is interactive\nso that the indexed diffractions could be expected in detail.</li>\n</ul>\n\n<h6 id=\"technical-note\">Technical note</h6>\n\n<ul>\n<li>The code below uses (sligthly modified) PyMatGen functions.</li>\n<li>Reason: PyMatGen plots with diffraction indexes are quite good.\nRe-programing would be quite difficult, boring, and useless.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.radial", "modulename": "ediff.radial", "kind": "module", "doc": "<h2 id=\"module-ediffradial\">Module: ediff.radial</h2>\n\n<p>The conversion of a 2D powder diffraction pattern\nto a 1D powder diffraction pattern = radially averaged intensity distribution.</p>\n"}, {"fullname": "ediff.radial.calc_radial_distribution", "modulename": "ediff.radial", "qualname": "calc_radial_distribution", "kind": "function", "doc": "<p>Calculate 1D radially averaged distrubution profile\nfrom 2D diffraction pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (2D-numpy array):\nThe numpy array which contains the 2D-diffractogram.</li>\n<li><strong>center</strong> (tuple/list of two floats, optional, default is None):\nThe accurate coordinates of the 2D-diffractogram.\nThis argument should be determined by ediff.center.CenterLocator\nto get the best results.\nIf not given (= if it defaults to None), the center is determined\nan approximate procedure using intensity center,\nwithout any refinement;\nthis is imprecise, especially in case of\ndiffraction patterns with a beamstopper.</li>\n<li><strong>output_file</strong> (str, optional, default is None):\nName of the output file.\nIf given, the calculated 1D profile is saved to <em>output_file</em>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>profile</strong> (2D numpy array containing two rows [R,I]):\n<ul>\n<li>R = radial_distance = dist. from the diffractogram center [pixels]</li>\n<li>I = intensity = intensities at given distances [arbitrary units]</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">center</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.radial.save_radial_distribution", "modulename": "ediff.radial", "qualname": "save_radial_distribution", "kind": "function", "doc": "<p>Save 1D radially averaged distrubution profile to output_file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>profile</strong> (2D numpy array containing two rows [R,I]):\n<ul>\n<li>R = radial_distance = dist. from the diffractogram center [pixels]</li>\n<li>I = intensity = intensities at given distances [arbitrary units]</li>\n</ul></li>\n<li><strong>filename</strong> (str):\nName of the output file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None.</strong>: The output is the radial distribution saved in a file with <em>filename</em>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">profile</span>, </span><span class=\"param\"><span class=\"n\">output_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.radial.read_radial_distribution", "modulename": "ediff.radial", "qualname": "read_radial_distribution", "kind": "function", "doc": "<p>Read 1D-radially averaged distrubution profile from a TXT-file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>filename</strong> (str):\nName of the input file;\nthe file is expected to contain two columns [distance, intensity].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>arr</strong> (2D-numpy array):\nThe array containing two columns: distance, intensity.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();