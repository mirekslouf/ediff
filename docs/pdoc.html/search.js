window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "ediff", "modulename": "ediff", "kind": "module", "doc": "<h2 id=\"package-ediff\">Package: EDIFF</h2>\n\n<p>Utilities for processing of electron diffraction patterns.</p>\n\n<ul>\n<li>Input:\n<ul>\n<li>2D powder electron diffraction pattern</li>\n</ul></li>\n<li>Output:\n<ul>\n<li>1D powder electron diffraction pattern</li>\n<li>the 1D pattern/profile is obtained by radial averaging of 2D pattern</li>\n<li>the final 1D profile can be calibrated and compared with calculated PXRD</li>\n</ul></li>\n</ul>\n\n<p>EDIFF modules:</p>\n\n<ul>\n<li>ediff.background = background correction (employs auxilliary package BGROUND)    </li>\n<li>ediff.center = find center of 2D-diffraction pattern</li>\n<li>ediff.io = input/output operations (read diffractogram, set plot params...)</li>\n<li>ediff.pxrd = calculate 1D-PXRD pattern for a known structure</li>\n<li>ediff.radial = calculate 1D-radial profile from 2D-diffraction pattern</li>\n</ul>\n\n<p>Auxiliary package BGROUND:</p>\n\n<ul>\n<li>the package enables simple, semi-automated, interactive background correction</li>\n<li>it is imported during ediff initialization and accessible as ediff.background</li>\n</ul>\n"}, {"fullname": "ediff.background", "modulename": "ediff.background", "kind": "module", "doc": "<h2 id=\"module-ediffbackground\">Module: ediff.background</h2>\n\n<p>Semi-automated background correction.    </p>\n\n<ul>\n<li>This module just imports key objects from external bground package.</li>\n<li>Therefore, it is just a formal incorporation of bground package to ediff.</li>\n</ul>\n\n<p>The source code is the whole module is rather brief,\nbut it contains a detailed explanation of how it works.</p>\n\n<ul>\n<li>See the source code of ediff.background\nif you are interested in technical details concerning the import.</li>\n<li>See documentation of bground package at <a href=\"https://pypi.org/project/bground\">https://pypi.org/project/bground</a>\nto find out how the background correction works.</li>\n</ul>\n"}, {"fullname": "ediff.center", "modulename": "ediff.center", "kind": "module", "doc": "<h2 id=\"module-ediffcenter\">Module: ediff.center</h2>\n\n<p>Find center of 2D diffraction pattern.</p>\n"}, {"fullname": "ediff.center.CenterEstimator", "modulename": "ediff.center", "qualname": "CenterEstimator", "kind": "class", "doc": "<p>Detection of the center of diffraction patterns.</p>\n\n<p>The center can be estimated in one of the following ways:</p>\n\n<ul>\n<li>Center of the intensity/mass in selected area.</li>\n<li>Center from three points (defined interactivelly)\nwhich define one ring in a powder electron diffraction pattern.</li>\n<li>Center estimated from Hough transform,\nwhich detects circles in the diffraction pattern.</li>\n</ul>\n\n<p>SUBCLASS : CenterLocator</p>\n\n<ul>\n<li>the subclass refines the position of the estimated center </li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_path</strong> (string):\ndirect path to an image with diffraction patterns</li>\n<li><strong>detection_method</strong> (string):\nSelection of a method for center calculation. String codes are:\n    - 'manual' : manual detection via 3 points\n    - 'intensity' : detection via maximum intensity\n    - 'hough' : automatic detection via Hough transform</li>\n<li><strong>correction_method</strong> (string):\nSelection of a method for center position correction. Default is None.\nString codes are:\n    - 'manual' : manual corection \n    - 'variance' : correction via variance minimization \n    - 'sum' : correction via sum maximization</li>\n<li><strong>heq</strong> (boolean, optional, default is False):\nAllow histogram equalization.\nThe equalization is virtual, the original image is unchanged.</li>\n<li><strong>icut</strong> (integer, optional, default is None):\nIntensity cut to enhance image contrast.\nExample: icut=300, all pixels intensities &gt;300 are set to 300.</li>\n<li><strong>cmap</strong> (str, optional, default is 'gray'):\nName of matplotlib colormap.\nAny valid colormap ('viridis','magma') can be used.</li>\n<li><strong>messages</strong> (bool, optional, default is False):\nPrint to terminal additional messages about program run.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>self.x</strong> (float):\nx-coordinate of the detected center</li>\n<li><strong>self.y</strong> (float):\ny-coordinate of the detected center</li>\n<li><strong>self.r</strong> (float):\nradius of the detected center (if available, othervise returns None)</li>\n</ul>\n"}, {"fullname": "ediff.center.CenterEstimator.__init__", "modulename": "ediff.center", "qualname": "CenterEstimator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_image</span>,</span><span class=\"param\">\t<span class=\"n\">detection_method</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">correction_method</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">heq</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">icut</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">csquare</span><span class=\"o\">=</span><span class=\"mi\">50</span>,</span><span class=\"param\">\t<span class=\"n\">cintensity</span><span class=\"o\">=</span><span class=\"mf\">0.8</span>,</span><span class=\"param\">\t<span class=\"n\">messages</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "ediff.center.CenterEstimator.input_image", "modulename": "ediff.center", "qualname": "CenterEstimator.input_image", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.center.CenterEstimator.correction_method", "modulename": "ediff.center", "qualname": "CenterEstimator.correction_method", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.center.CenterEstimator.heq", "modulename": "ediff.center", "qualname": "CenterEstimator.heq", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.center.CenterEstimator.icut", "modulename": "ediff.center", "qualname": "CenterEstimator.icut", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.center.CenterEstimator.to_refine", "modulename": "ediff.center", "qualname": "CenterEstimator.to_refine", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.center.CenterEstimator.cmap", "modulename": "ediff.center", "qualname": "CenterEstimator.cmap", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.center.CenterEstimator.messages", "modulename": "ediff.center", "qualname": "CenterEstimator.messages", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.center.CenterEstimator.marker_size", "modulename": "ediff.center", "qualname": "CenterEstimator.marker_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.center.CenterEstimator.detection_intensity", "modulename": "ediff.center", "qualname": "CenterEstimator.detection_intensity", "kind": "function", "doc": "<p>Find center of intensity/mass of an array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (2D-numpy array):\nThe array, whose intensity center will be determined.</li>\n<li><strong>csquare</strong> (int, optional, default is 20):\nThe size/edge of the square in the (geometrical) center.\nThe intensity center will be searched only within the central square.\nReasons: To avoid other spots/diffractions and\nto minimize the effect of possible intensity assymetry around center.</li>\n<li><strong>cintensity</strong> (float, optional, default is 0.8):\nThe intensity fraction.\nWhen searching the intensity center, we will consider only\npixels with intensity &gt; max.intensity.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xc,yc</strong> (float,float):\nXY-coordinates of the intensity/mass center of the array.\nRound XY-coordinates if you use them for image/array calculations.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">csquare</span>, </span><span class=\"param\"><span class=\"n\">cintensity</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterEstimator.detection_3points", "modulename": "ediff.center", "qualname": "CenterEstimator.detection_3points", "kind": "function", "doc": "<p>In the input image, select manually 3 points defining a circle using\na key press event \n    - press '1' to select a point</p>\n\n<p>If the user is not satisfied with the point selection, it can be\ndeleted using a key press event:\n    - press '2' to delete the most recent\n    - press '3' to delete the point closest to the cursor</p>\n\n<p>If the user is satisified with the points selected, the rest \nof the program will be executed \n    - press 'd' to proceed &gt;DONE&lt;</p>\n\n<p>Coordinates of the center and radius will be calculated automatically\nusing method self.calculate_circle()</p>\n\n<p>In addition, the user will be able to manually adjust the original\ncenter position by using pre-defined keys.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>plot_results</strong> (int, binary):\nPlot the pattern determined by pixels selected by the user.\nDefault is 1. To cancel visualization, set plot_results = 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>self.x</strong> (float64):\nx-coordinate of the detected center</li>\n<li><strong>self.y</strong> (float64):\ny-coordinate of the detected center</li>\n<li><strong>self.r</strong> (float64):\nradius of the detected center\n(if available, othervise returns None)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterEstimator.adjustment_3points", "modulename": "ediff.center", "qualname": "CenterEstimator.adjustment_3points", "kind": "function", "doc": "<p>Adjustment of the center position calculated from 3 points.\nInteractive refinement using keys:</p>\n\n<p>The user can change the position of the center of the diffraction\npattern and also the radius of the detected pattern using keys:\n    - left / right / top / down arrows : move left / right / top / down\n    - '+' : increase radius\n    - '-' : decrease radius\n    - 'd' : done, termination of the refinement</p>\n\n<p>If the interactive figure is closed without any modifications,\nthe function returns input variables and the proccess terminates.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>fig</strong> (figure.Figure object):\ninteractive figure in which a diffraction pattern has been\nmanually detected.</li>\n<li><strong>circle</strong> (patches.Circle object):\ncircle defined via 3 points manually delected</li>\n<li><strong>center</strong> (tuple):\ncalculated center of the input circle.</li>\n<li><strong>plot_results</strong> (boolean):\nvisualize results. The default is 1 (plot detected center).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xy</strong> (tuple):\nx,y-coordinates of the center of the diffraction pattern.</li>\n<li><strong>r</strong> (integer):\nradius of the diffraction pattern.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fig</span>, </span><span class=\"param\"><span class=\"n\">circle</span>, </span><span class=\"param\"><span class=\"n\">center</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterEstimator.detection_Hough", "modulename": "ediff.center", "qualname": "CenterEstimator.detection_Hough", "kind": "function", "doc": "<p>Perform Hough transform to detect center of diffraction patterns.\nThis is a method to automatically detect circular diffraction patterns</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>plot_results</strong> (int, binary):\nPlot the pattern determined by pixels selected by the user.\nDefault is 1. To cancel visualization, set plot_results = 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>self.x</strong> (float64):\nx-coordinate of the detected center</li>\n<li><strong>self.y</strong> (float64):\ny-coordinate of the detected center</li>\n<li><strong>self.r</strong> (float64):\nradius of the detected center</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterEstimator.calculate_circle", "modulename": "ediff.center", "qualname": "CenterEstimator.calculate_circle", "kind": "function", "doc": "<p>Calculates coordinates of the center and radius of a circle defined via\n3 points determined by the user. Plots the calculated circle, detected \npoints and marks the center.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>plot_results</strong> (int, binary):\nPlot the calculated center and circle. To cancel visualization, \nset plot_results = 0.</li>\n<li><strong>self.coords</strong> (array of float64):\nCoordinates of 3 manually selected points</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>self.x</strong> (float64):\nx-coordinate of the detected center</li>\n<li><strong>self.y</strong> (float64):\ny-coordinate of the detected center</li>\n<li><strong>self.r</strong> (float64):\nradius of the detected center</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterEstimator.visualize_center", "modulename": "ediff.center", "qualname": "CenterEstimator.visualize_center", "kind": "function", "doc": "<p>Visualize detected diffraction patterns and mark the center.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tit</strong> (string):\nname of the method used for circle detection</li>\n<li><strong>x</strong> (float64):\nx-coordinate of the detected center</li>\n<li><strong>y</strong> (float64):\ny-coordinate of the detected center</li>\n<li><strong>r</strong> (float64):\nradius of the detected center</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None.</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">r</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterEstimator.central_square", "modulename": "ediff.center", "qualname": "CenterEstimator.central_square", "kind": "function", "doc": "<p>Return central square from an array</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (2D-numpy array):\nThe original array from which the central_square will be extracted</li>\n<li><strong>csquare</strong> (int, optional, default is 20):\nThe size/edge of the square in the (geometrical) center.\nThe intensity center will be searched only within the central square.\nReasons: To avoid other spots/diffractions and\nto minimize the effect of possible intensity assymetry around center.</li>\n<li><strong>xcenter</strong> (float64):\nx-coordinate of array center. Deafault is None</li>\n<li><strong>ycenter</strong> (float64):\ny-coordinate of array center. Deafault is None</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>arr2</strong> (2D-numpy array):\ncentral square extracted from input array</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">csquare</span>, </span><span class=\"param\"><span class=\"n\">xcenter</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ycenter</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator", "modulename": "ediff.center", "qualname": "CenterLocator", "kind": "class", "doc": "<h6 id=\"subclass-of-circleestimator\">SUBCLASS of CircleEstimator</h6>\n\n<p>Automatic adjustment of the center position of diffraction patterns,\nwhich was found using methods defined in the class CircleDetection</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_path</strong> (string):\ndirect path to an image with diffraction patterns</li>\n<li><strong>detection_method</strong> (string):\nSelection of a method for center calculation. String codes are:\n    - 'manual' : manual detection via 3 points\n    - 'intensity' : detection via maximum intensity\n    - 'hough' : automatic detection via Hough transform</li>\n<li><strong>correction_method</strong> (string):\nSelection of a method for center position correction. Default is None.\nString codes are:\n    - 'manual' : manual corection \n    - 'var' : correction via variance minimization \n    - 'sum' : correction via sum maximization</li>\n<li><strong>heq</strong> (boolean):\nAllow histogram equalization. The default is 0 (no enhancement)</li>\n<li><strong>icut</strong> (boolean):\nAllow image enhancement. The default is 0 (no enhancement)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>self.xx</strong> (int32):\nadjusted x-coordinate of the detected center</li>\n<li><strong>self.yy</strong> (int32):\nadjusted y-coordinate of the detected center</li>\n<li><strong>self.rr</strong> (int32):\nradius of the detected center</li>\n</ul>\n", "bases": "CenterEstimator"}, {"fullname": "ediff.center.CenterLocator.__init__", "modulename": "ediff.center", "qualname": "CenterLocator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image_path</span>,</span><span class=\"param\">\t<span class=\"n\">detection_method</span>,</span><span class=\"param\">\t<span class=\"n\">correction_method</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">heq</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">icut</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">messages</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">final_replot</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "ediff.center.CenterLocator.messages", "modulename": "ediff.center", "qualname": "CenterLocator.messages", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.center.CenterLocator.image_path", "modulename": "ediff.center", "qualname": "CenterLocator.image_path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.center.CenterLocator.preprocess_images", "modulename": "ediff.center", "qualname": "CenterLocator.preprocess_images", "kind": "function", "doc": "<p>FOR AUTOMATIC METHODS OPTIMIZATION AND MORE UNIVERSAL SOLUTIONS</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">to</span> <span class=\"n\">be</span> <span class=\"n\">finished</span> <span class=\"n\">later</span><span class=\"p\">,</span> <span class=\"k\">as</span> <span class=\"n\">it</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"n\">the</span> <span class=\"n\">most</span> <span class=\"n\">important</span> <span class=\"n\">thing</span> <span class=\"n\">now</span>\n</code></pre>\n</div>\n\n<p>Function for input image preprocessing based on the methods \ndefined in the class initialization - self.detection_method, \nself.correction_method.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>preInit</strong> (bool, optional):\nPerform preprocessing of the input image (when using icut or heq). \nThis is called automatically every time, if no preprocessing\nspecified, the detection and refinement will be performed on \noriginal image. The default is 0.</li>\n<li><strong>preHough</strong> (bool, optional):\nPerform preprocessing for automatic detection via Hough transform.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>manu</strong> (NumPy array):\nPre-processed image for the manual detection method</li>\n<li><strong>edges</strong> (array of bool):\nDetected edges via Canny detector for automatic Hough transform</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">preInit</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preHough</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preManual</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preVar</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preSum</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">preInt</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.output", "modulename": "ediff.center", "qualname": "CenterLocator.output", "kind": "function", "doc": "<p>Manage variables that should be send as the output of the center \ndetection. </p>\n\n<p>If there were set parameters detection_method and \ncorrection method during the class initialization, the output will be\ncoordinates x, y of the center detected by the detection_method and \ncoordinates x, y of refined center position by the correction method.</p>\n\n<p>If there was not set the correction_method parameter, the function\noutputs x, y coordinates of the detected center and None, None for\nthe refined coordinates.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>x</strong> (float):\nx-coordinate of the center detected via detection_method</li>\n<li><strong>y</strong> (float):\ny-coordinate of the center detected via detection_method</li>\n<li><strong>xx</strong> (float):\nx-coordinate of the center detected via refinement_method</li>\n<li><strong>yy</strong> (float):\ny-coordinate of the center detected via refinement_method</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.ref_interactive", "modulename": "ediff.center", "qualname": "CenterLocator.ref_interactive", "kind": "function", "doc": "<p>Manual refinement of the detected diffraction pattern via one of \nthe methods provided in the class CircleDetection.</p>\n\n<p>The user can change the position of the center of the diffraction\npattern and also the radius of the detected pattern using keys:\n    - left / right / top / down arrows : move left / right / top / down\n    - '+' : increase radius\n    - '-' : decrease radius\n    - 'd' : done, termination of the refinement</p>\n\n<p>If the interactive figure is closed without any modifications,\nthe function returns input variables and the proccess terminates.</p>\n\n<p>The results are shown in a figure when the refinement is successful.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>px</strong> (float64):\nx-coordinate of the center</li>\n<li><strong>py</strong> (float64):\ny-coordinate of the center</li>\n<li><strong>pr</strong> (float64):\nradius of the circular diffraction pattern</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>x</strong> (float64):\nnew x-coordinate of the center</li>\n<li><strong>y</strong> (float64):\nnew y-coordinate of the center</li>\n<li><strong>r</strong> (float64):\nnew radius of the circular diffraction pattern</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.ref_var", "modulename": "ediff.center", "qualname": "CenterLocator.ref_var", "kind": "function", "doc": "<p>Adjust center coordinates of a detected circular diffraction pattern.\nThe center adjustment is based on variance minimization.</p>\n\n<p>The 8-neighbourhood pixels (x) of the current center (o) \nwill be tested regarding the minimization:</p>\n\n<ul>\n<li><p>x x x : (px - dx, py + dy) (px, py + dy) ( px + dx, py + dy)</p></li>\n<li><p>x o x : (px - dx, py)      (px, py)      (px + dx, py)</p></li>\n<li><p>x x x : (px - dx, py - dy) (px, py - dy) (px + dx, py - dy)</p></li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>self.image</strong> (array of uint8):\nInput image in which the diffraction pattern is to be found</li>\n<li><strong>px</strong> (float64):\nx-coordinate of the detected center to be adjusted</li>\n<li><strong>py</strong> (float64):\ny-coordinate of the detected center to be adjusted</li>\n<li><strong>pr</strong> (float64):\nradius of the detected center</li>\n<li><strong>plot_results</strong> (integer (default = 1)):\nPlot Detected center. The default is 1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>px</strong> (array of int32):\ncorrected x-coordinates of pixels from circle border</li>\n<li><strong>py</strong> (array of int32):\ncorrected y-coordinates of pixels from circle border</li>\n<li><strong>pr</strong> (array of int32):\nradius of the detected center</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.ref_sum", "modulename": "ediff.center", "qualname": "CenterLocator.ref_sum", "kind": "function", "doc": "<p>Adjust center position based on gradient optimization method\nvia maximization of intensity sum.</p>\n\n<p>The 8-neighbourhood pixels (x) of the current center (o) \nwill be tested regarding the maximization:</p>\n\n<ul>\n<li><p>x x x : (px - dx, py + dy) (px, py + dy) ( px + dx, py + dy)</p></li>\n<li><p>x o x : (px - dx, py)      (px, py)      (px + dx, py)</p></li>\n<li><p>x x x : (px - dx, py - dy) (px, py - dy) (px + dx, py - dy)</p></li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>px</strong> (float64):\nx-coordinate of the detected center to be adjusted.</li>\n<li><strong>py</strong> (float64):\ny-coordinate of the detected center to be adjusted.</li>\n<li><strong>pr</strong> (float64):\nradius of the detected center.</li>\n<li><strong>plot_results</strong> (int, optional):\nPlot Detected center. \nThe default is 1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<p>best_center[0] : float64\n    Adjusted x-coordinate of the center.\nbest_center[1] : float64\n    Adjusted y-coordinate of the center.\nbest_radius : float64\n    The adjusted radius of the circular diffraction pattern.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span>, </span><span class=\"param\"><span class=\"n\">plot_results</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.get_circle_pixels", "modulename": "ediff.center", "qualname": "CenterLocator.get_circle_pixels", "kind": "function", "doc": "<p>Get coordinates of pixels defining circle border</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>self.image_path</strong> (str):\ndirect path to a image with diffraction patterns</li>\n<li><strong>xc</strong> (float64):\nx-coordinate of the detected center</li>\n<li><strong>yc</strong> (float64):\ny-coordinate of the detected center</li>\n<li><strong>radius</strong> (float64):\nradius of the detected center</li>\n<li><strong>num_points</strong> (float64):\nnumber of border points. The default is 360</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>x</strong> (array of float64):\nx-coordinates of pixels from circle border</li>\n<li><strong>y</strong> (array of float64):\ny-coordinates of pixels from circle border</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xc</span>, </span><span class=\"param\"><span class=\"n\">yc</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">num_points</span><span class=\"o\">=</span><span class=\"mi\">360</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.intensity_sum", "modulename": "ediff.center", "qualname": "CenterLocator.intensity_sum", "kind": "function", "doc": "<p>Summation of intensity values of pixels of a diffraction pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong> (array of uint8):\nimage from which the diffraction pattern has been detected.</li>\n<li><strong>px</strong> (float64):\nx-coordinate of the center of the diffraction pattern.</li>\n<li><strong>py</strong> (float64):\ny-coordinate of the center of the diffraction pattern.</li>\n<li><strong>pr</strong> (float64):\nradius of the diffraction pattern.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>s</strong> (float64):\nintensity sum</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.intensity_var", "modulename": "ediff.center", "qualname": "CenterLocator.intensity_var", "kind": "function", "doc": "<p>Variance of intensity values of pixels of a diffraction pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image</strong> (array of uint8):\nimage from which the diffraction pattern has been detected.</li>\n<li><strong>px</strong> (float64):\nx-coordinate of the center of the diffraction pattern.</li>\n<li><strong>py</strong> (float64):\ny-coordinate of the center of the diffraction pattern.</li>\n<li><strong>pr</strong> (float64):\nradius of the diffraction pattern.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>s</strong> (float64):\nintensity variance</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.CenterLocator.visualize_refinement", "modulename": "ediff.center", "qualname": "CenterLocator.visualize_refinement", "kind": "function", "doc": "<p>Visualize diffraction patterns and center after correction</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>px</strong> (float64):\nx-coordinate before correction.</li>\n<li><strong>py</strong> (float64):\ny-coordinate before correction.</li>\n<li><strong>pr</strong> (float64):\nradius before correction.</li>\n<li><strong>xy</strong> (float64):\nxy-coordinates after correction.</li>\n<li><strong>r</strong> (float64):\nradius after correction.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None.</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">px</span>, </span><span class=\"param\"><span class=\"n\">py</span>, </span><span class=\"param\"><span class=\"n\">pr</span>, </span><span class=\"param\"><span class=\"n\">xy</span>, </span><span class=\"param\"><span class=\"n\">r</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.HandlerCircle", "modulename": "ediff.center", "qualname": "HandlerCircle", "kind": "class", "doc": "<p>Help class for visualization. Not to be used outside of the module.</p>\n", "bases": "matplotlib.legend_handler.HandlerBase"}, {"fullname": "ediff.center.HandlerCircle.create_artists", "modulename": "ediff.center", "qualname": "HandlerCircle.create_artists", "kind": "function", "doc": "<p>Return the legend artists generated.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>legend</strong> (<code>~matplotlib.legend.Legend</code>):\nThe legend for which these legend artists are being created.</li>\n<li><strong>orig_handle</strong> (<code>~matplotlib.artist.Artist</code> or similar):\nThe object for which these legend artists are being created.</li>\n<li><strong>xdescent, ydescent, width, height</strong> (int):\nThe rectangle (<em>xdescent</em>, <em>ydescent</em>, <em>width</em>, <em>height</em>) that the\nlegend artists being created should fit within.</li>\n<li><strong>fontsize</strong> (int):\nThe fontsize in pixels. The legend artists being created should\nbe scaled according to the given fontsize.</li>\n<li><strong>trans</strong> (<code>~matplotlib.transforms.Transform</code>):\nThe transform that is applied to the legend artists being created.\nTypically from unit coordinates in the handler box to screen\ncoordinates.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">legend</span>,</span><span class=\"param\">\t<span class=\"n\">orig_handle</span>,</span><span class=\"param\">\t<span class=\"n\">xdescent</span>,</span><span class=\"param\">\t<span class=\"n\">ydescent</span>,</span><span class=\"param\">\t<span class=\"n\">width</span>,</span><span class=\"param\">\t<span class=\"n\">height</span>,</span><span class=\"param\">\t<span class=\"n\">fontsize</span>,</span><span class=\"param\">\t<span class=\"n\">trans</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.center.IntensityCenter", "modulename": "ediff.center", "qualname": "IntensityCenter", "kind": "class", "doc": "<p>Simple center determination for a symmetric diffractogram.</p>\n\n<ul>\n<li>The center is determined as a center of intensity.</li>\n<li>This works well for simple, symmetric diffraction patters, which are:\n(i) without beamstopper, (ii) pre-centered, and (iii) powder-like.</li>\n<li>A real-life example of a simple symmetric diffractogram:\na good powder electron diffraction pattern from STEMDIFF software.</li>\n<li>This class is a legacy from previous EDIFF versions;\nit is kept mostly for backward compatibility.\nThe functions in this class can be (and should be)\nreplaced by a simple call of ediff.center.CenterLocator object.</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Center determination in a simple symmetric diffraction pattern</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (center = just center_of_intensity, no refinement</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (1) Old way = this (old, legacy) IntensityCenter class:</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xc</span><span class=\"p\">,</span><span class=\"n\">yc</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">IntensityCenter</span><span class=\"o\">.</span><span class=\"n\">center_of_intensity</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">arr</span><span class=\"p\">,</span> <span class=\"n\">csquare</span><span class=\"o\">=</span><span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"n\">cintensity</span><span class=\"o\">=</span><span class=\"mf\">0.8</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (2) New way = newer (and more universal) CenterLocator class:</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xc</span><span class=\"p\">,</span><span class=\"n\">yc</span> <span class=\"o\">=</span> <span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">center</span><span class=\"o\">.</span><span class=\"n\">CenterLocator</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">arr</span><span class=\"p\">,</span> <span class=\"n\">detection_method</span><span class=\"o\">=</span><span class=\"s1\">&#39;intensity&#39;</span><span class=\"p\">,</span> <span class=\"n\">csquare</span><span class=\"o\">=</span><span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"n\">cintensity</span><span class=\"o\">=</span><span class=\"mf\">0.8</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n"}, {"fullname": "ediff.center.IntensityCenter.center_of_intensity", "modulename": "ediff.center", "qualname": "IntensityCenter.center_of_intensity", "kind": "function", "doc": "<p>Find center of intensity/mass of an array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (2D-numpy array):\nThe array, whose intensity center will be determined.</li>\n<li><strong>csquare</strong> (int, optional, default is 20):\nThe size/edge of the square in the (geometrical) center.\nThe intensity center is searched only within the central square.\nReasons: To avoid other spots/diffractions and\nto minimize the effect of an intensity assymetry around center.</li>\n<li><strong>cintensity</strong> (float, optional, default is 0.8):\nThe intensity fraction.\nWhen searching the intensity center, we will consider only\npixels with intensity &gt; max.intensity.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>xc,yc</strong> (float,float):\nXY-coordinates of the intensity/mass center of the array.\nRound XY-coordinates if you use them for image/array calculations.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">csquare</span><span class=\"o\">=</span><span class=\"mi\">20</span>, </span><span class=\"param\"><span class=\"n\">cintensity</span><span class=\"o\">=</span><span class=\"mf\">0.8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io", "modulename": "ediff.io", "kind": "module", "doc": "<h2 id=\"module-ediffio\">Module: ediff.io</h2>\n\n<p>Input/output functions for package ediff.</p>\n"}, {"fullname": "ediff.io.read_image", "modulename": "ediff.io", "qualname": "read_image", "kind": "function", "doc": "<p>Read grayscale image into 2D numpy array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_name</strong> (string or pathlib object):\nName of image that should read into numpy 2D array.</li>\n<li><strong>itype</strong> (string ('8bit'  or '16bit')):\ntype of the image: 8 or 16 bit grayscale</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>2D numpy array</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">image_name</span>, </span><span class=\"param\"><span class=\"n\">itype</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.set_plot_parameters", "modulename": "ediff.io", "qualname": "set_plot_parameters", "kind": "function", "doc": "<p>Set global plot parameters (mostly for plotting in Jupyter).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>size</strong> (tuple of two floats, optional, the default is (8,6)):\nSize of the figure (width, height) in [cm].</li>\n<li><strong>dpi</strong> (int, optional, the defalut is 100):\nDPI of the figure.</li>\n<li><strong>fontsize</strong> (int, optional, the default is 8):\nSize of the font used in figure labels etc.</li>\n<li><strong>my_defaults</strong> (bool, optional, default is True):\nIf True, some reasonable additional defaults are set,\nnamely line widths and formats.</li>\n<li><strong>my_rcParams</strong> (dict, optional, default is None):\nDictionary in plt.rcParams format\ncontaining any other allowed global plot parameters.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None; the result is a modification of the global plt.rcParams variable.</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">)</span>, </span><span class=\"param\"><span class=\"n\">dpi</span><span class=\"o\">=</span><span class=\"mi\">100</span>, </span><span class=\"param\"><span class=\"n\">fontsize</span><span class=\"o\">=</span><span class=\"mi\">8</span>, </span><span class=\"param\"><span class=\"n\">my_defaults</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">my_rcParams</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.io.plot_radial_distributions", "modulename": "ediff.io", "qualname": "plot_radial_distributions", "kind": "function", "doc": "<p>Plot one or more 1D-radial distrubution files in one graph.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_to_plot</strong> (2D-list):\n<ul>\n<li>list with several rows containing [data, linestyle, label]</li>\n<li>data = data for plotting - they can be one of the following:\n<ul>\n<li>PNG filename = str, a PNG-file = 2D diffraction pattern</li>\n<li>TXT filename = str, a text file = 1D diffraction profile</li>\n<li>2D-array = a numpy array, containg 2D diffraction pattern</li>\n<li>1D-array = a numpy array, containing 1D diffraction profile</li>\n<li>Note1: 2D-pattern = a square image/array with intensities</li>\n<li>Note2: 1D-profile = a text file/array with two cols/rows = [R,I],\nwhere R = distance from center, I = diffraction intensity</li>\n</ul></li>\n<li>linestyle = matplotlib.pyplot format, such as 'r-' (red line)</li>\n<li>label = name of the data, which will appear in the plot legend</li>\n</ul></li>\n<li><strong>xlimit</strong> (int):\nmaximum of the X-axis</li>\n<li><strong>ylimit</strong> (int):\nmaximum of the Y-axis</li>\n<li><strong>output_file</strong> (int, optional, default=None):\nName of the output file;\nif the <em>output</em> argument is given,\nthe plot is not only shown on screen, but also saved in <em>output</em> file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Nothing</strong>: The output is the plot on screen\n(and in <em>output file</em> if the <em>output</em> argument was given).</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>This function is quite flexible.</li>\n<li>It can plot one radial distribution or more.</li>\n<li>It can take data from PNG-files, TXT-files, 2D-arrays and 1D-arrays.</li>\n<li>If the input is a PNG-file or2D-array,\nthe center is just <em>estimated</em> as as the center of intensity;\ntherefore, this works only for good diffractograms with a central spot.</li>\n<li>This makes the code a more complex, but it is convenient for the user.</li>\n<li>An example of fast comparison of three 1D-distributions\ntaken from three 2D-diffractograms in the form of 16-bit PNG images:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ediff</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">plot_radial_distributions</span><span class=\"p\">(</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">data_to_plot</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"p\">[</span><span class=\"s1\">&#39;sum_all_16bit.png&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;k:&#39;</span><span class=\"p\">,</span>  <span class=\"s1\">&#39;All data&#39;</span><span class=\"p\">],</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"p\">[</span><span class=\"s1\">&#39;sum_f_16bit.png&#39;</span><span class=\"p\">,</span>   <span class=\"s1\">&#39;b--&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;F data&#39;</span><span class=\"p\">],</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"p\">[</span><span class=\"s1\">&#39;sum_fd_16bit.png&#39;</span><span class=\"p\">,</span>  <span class=\"s1\">&#39;r-&#39;</span><span class=\"p\">,</span>  <span class=\"s1\">&#39;FD data&#39;</span><span class=\"p\">]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">xlimit</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"n\">ylimit</span><span class=\"o\">=</span><span class=\"mi\">300</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"s1\">&#39;sums_final_1d.png&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_to_plot</span>, </span><span class=\"param\"><span class=\"n\">xlimit</span>, </span><span class=\"param\"><span class=\"n\">ylimit</span>, </span><span class=\"param\"><span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd", "modulename": "ediff.pxrd", "kind": "module", "doc": "<h2 id=\"module-ediffpxrd\">Module: ediff.pxrd</h2>\n\n<p>Calculation of powder X-ray diffraction patterns.</p>\n"}, {"fullname": "ediff.pxrd.Crystal", "modulename": "ediff.pxrd", "qualname": "Crystal", "kind": "class", "doc": "<p>Define crystal structure.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>structure</strong> (structure object):\n<ul>\n<li>The <em>structure object</em> is usually obtained from a CIF-file\n(CIF = Crystallographic Information File).</li>\n<li>The <em>CIF files</em> are available in crystallographic databases,\nsuch as <a href=\"http://www.crystallography.net\"><a href=\"http://www.crystallography.net\">http://www.crystallography.net</a></a></li>\n<li>The exact type of the object is <em>pymatgen.core.structure.Structure</em>\n<ul>\n<li>This indicates that the structure is read from CIF by means of\npymatgen package (which works behind the sceenes).</li>\n<li>This also means that the structure can be created by any\nother way available in pymatgen <a href=\"https://pymatgen.org/\"><a href=\"https://pymatgen.org/\"><a href=\"https://pymatgen.org/\">https://pymatgen.org/</a></a></a></li>\n<li>Nevertheless, for common usage it is enough to\nread the structure from CIF, ignoring technical details.</li>\n</ul></li>\n</ul></li>\n<li><strong>temp_factors</strong> (float or dictionary, optional, the default is 0.8):\n<ul>\n<li>Temperature factors characterize thermal movement of atoms.</li>\n<li>If a float value is given,\nall elements have this temperature factor value.</li>\n<li>If a dictionary is given,\nthe elements have the values defined in the dictionary;\na sample input dictionary: <code>temp_factors = {'Na':1.2, 'Cl':1.1}</code>.</li>\n</ul></li>\n</ul>\n"}, {"fullname": "ediff.pxrd.Crystal.__init__", "modulename": "ediff.pxrd", "qualname": "Crystal.__init__", "kind": "function", "doc": "<ul>\n<li>Initialize Crystal object.</li>\n<li>The parameters are described above in class definition.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">structure</span>, </span><span class=\"param\"><span class=\"n\">temp_factors</span><span class=\"o\">=</span><span class=\"mf\">0.8</span></span>)</span>"}, {"fullname": "ediff.pxrd.Crystal.read_structure_from_CIF", "modulename": "ediff.pxrd", "qualname": "Crystal.read_structure_from_CIF", "kind": "function", "doc": "<p>Read crystall structure from CIF file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>CIF</strong> (str or path object):\n<ul>\n<li>The filename of CIF file.</li>\n<li>CIF = Crystallographic Information File\ncontains information about crystal structure.</li>\n<li>CIF files are usually obtained from crystallographic databases,\nsuch as <a href=\"http://www.crystallography.net\"><a href=\"http://www.crystallography.net\">http://www.crystallography.net</a></a></li>\n</ul></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>structure</strong> (structure object):\n<ul>\n<li>The exact type of the object is\n<em>pymatgen.core.structure.Structure</em>.</li>\n<li>Nevertheless, in the structure objects are usually\ncreated from CIF files (pymatgen is hidden for a common user).</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">CIF</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.Crystal.get_elements", "modulename": "ediff.pxrd", "qualname": "Crystal.get_elements", "kind": "function", "doc": "<p>Get a list of all elements, which are contained in given structure.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>structure</strong> (structure object):\nTypically, the structure objects are\ncreated by function <em>read_structure_from_CIF</em> above.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>list_of_elements</strong> (list):\nList with symbols of all elements\nthat are present in given <em>structure</em>.</li>\n</ul>\n\n<h6 id=\"technical-note\">Technical note</h6>\n\n<ul>\n<li>The elements are obtained from <em>structure</em> object.</li>\n<li>The structure object = pymatgen.core.structure.Structure.</li>\n<li>The list of element names si obtained by a set of tricks\nspecific to pymatgen-structure object.</li>\n<li>These tricks were revealed by inspecting the original\npymatgen.core.structure.Structure in Spyder,\nby means of shortcuts Ctrl+I (help) and Ctrl+G (go to code).</li>\n<li>Common users do not have to use this function.</li>\n<li>The function is just used internally, when setting\ntemperature factors of the elements contained in given <em>structure</em>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">structure</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.Crystal.get_elements_with_temp_factors", "modulename": "ediff.pxrd", "qualname": "Crystal.get_elements_with_temp_factors", "kind": "function", "doc": "<p>Get a dictionary, which contains symbols and temperature factors\nof all elements, which are present in given structure.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>structure</strong> (structure object):\nTypically, the structure objects are\ncreated by function <em>read_structure_from_CIF</em> above.</li>\n<li><strong>B</strong> (float, optional, the default is 0.8):</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>elements_with_temp_factors</strong> (dict):\nDictionary with symbols and temperature factors\nof all elements, which are present in given <em>structure</em>.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The dictionary is in the format required by pymatgen package.</li>\n<li>The pymatgen package is used for PXRD calculations,\nbut these calculations are hidden from common users.</li>\n<li>Common users do not use this function.</li>\n<li>The function is just used internally, when setting\ntemperature factors of the elements contained in given <em>structure</em>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">structure</span>, </span><span class=\"param\"><span class=\"n\">B</span><span class=\"o\">=</span><span class=\"mf\">0.8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.Experiment", "modulename": "ediff.pxrd", "qualname": "Experiment", "kind": "class", "doc": "<p>Define experimental parameters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>wavelength</strong> (float):\nWavelength of the X-rays.\nTypical values are 1.54 A (CuKa) or 0.71 A (MoKa).</li>\n<li><strong>two_theta_range</strong> (list/tuple of two floats):\nMinimal and maximal diffraction angle;\nboth values are TwoTheta angle in [deg] (for given <em>wavelength</em>).</li>\n</ul>\n"}, {"fullname": "ediff.pxrd.Experiment.__init__", "modulename": "ediff.pxrd", "qualname": "Experiment.__init__", "kind": "function", "doc": "<ul>\n<li>Initialize Experimental object.</li>\n<li>The parameters are described above in class definition.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">wavelength</span>, </span><span class=\"param\"><span class=\"n\">two_theta_range</span></span>)</span>"}, {"fullname": "ediff.pxrd.Experiment.wavelength", "modulename": "ediff.pxrd", "qualname": "Experiment.wavelength", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.pxrd.Experiment.two_theta_range", "modulename": "ediff.pxrd", "qualname": "Experiment.two_theta_range", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.pxrd.PlotParameters", "modulename": "ediff.pxrd", "qualname": "PlotParameters", "kind": "class", "doc": "<p>Define local+global parameters for plotting.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>title</strong> (str):\nTitle of the plot.</li>\n<li><strong>x_axis</strong> (str, 'TwoTheta','S','q' or 'dhkl', optional, default is 'q'):\nQuantity for X-axis.</li>\n<li><strong>rcParams</strong> (dict; optional, the default is empty dictionary {}):\nThe dictionary should have the format of mathplotlib.pyplot.rcParams.\nThe argmument is passed to matplotlib.pyplot.rcParams.update.\nThis enables to override current rcParams, if necessary.</li>\n</ul>\n"}, {"fullname": "ediff.pxrd.PlotParameters.__init__", "modulename": "ediff.pxrd", "qualname": "PlotParameters.__init__", "kind": "function", "doc": "<ul>\n<li>Initialize PlotParameters object.</li>\n<li>The parameters are described above in class definition.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">x_axis</span><span class=\"o\">=</span><span class=\"s1\">&#39;q&#39;</span>, </span><span class=\"param\"><span class=\"n\">xlim</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">rcParams</span><span class=\"o\">=</span><span class=\"p\">{}</span></span>)</span>"}, {"fullname": "ediff.pxrd.PlotParameters.title", "modulename": "ediff.pxrd", "qualname": "PlotParameters.title", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.pxrd.PlotParameters.x_axis", "modulename": "ediff.pxrd", "qualname": "PlotParameters.x_axis", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.pxrd.PlotParameters.xlim", "modulename": "ediff.pxrd", "qualname": "PlotParameters.xlim", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.pxrd.PeakProfiles", "modulename": "ediff.pxrd", "qualname": "PeakProfiles", "kind": "class", "doc": "<p>Define profile of diffraction peaks.</p>\n\n<ul>\n<li>This class is employed only as a namespace.</li>\n<li>It contains three functions/definitions of diffratction peak profiles.</li>\n</ul>\n"}, {"fullname": "ediff.pxrd.PeakProfiles.gaussian", "modulename": "ediff.pxrd", "qualname": "PeakProfiles.gaussian", "kind": "function", "doc": "<p>Gaussian function (~ profile for PXRD calculation).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (numpy array):\nX-variable of Gaussian function.</li>\n<li><strong>m</strong> (float):\nMean value = the center of Gaussian function.</li>\n<li><strong>s</strong> (float):\nStandard deviation = the width of Gaussian function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>NumPy array</strong>: The array with Y-values of the function; Y = Gaussian(X).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PeakProfiles.lorentzian", "modulename": "ediff.pxrd", "qualname": "PeakProfiles.lorentzian", "kind": "function", "doc": "<p>Lorentzian function (~ profile for PXRD calculation).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (numpy array):\nX-variable of Lorentzian function.</li>\n<li><strong>m</strong> (float):\nMean value = the center of Lorentzian function.</li>\n<li><strong>s</strong> (float):\nStandard deviation = the width of Lorentzian function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>NumPy array</strong>: The array with Y-values of the functin; Y = Lorenzian(X).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PeakProfiles.pseudo_voigt", "modulename": "ediff.pxrd", "qualname": "PeakProfiles.pseudo_voigt", "kind": "function", "doc": "<p>Pseudo-Voigt function (~ profile for PXRD calculation).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (numpy array):\nX-variable of pseudo-Voigt function.</li>\n<li><strong>m</strong> (float):\nMean value = the center of pseudo-Voigt function.</li>\n<li><strong>s</strong> (float):\nStandard deviation = the width of pseudo-Voigt function.</li>\n<li><strong>n</strong> (float, optional, the default is 0.5):\nRatio between Gaussian and Lorentzian components.\nIn the very first approximation, we can set n = 0.5.\nFor more details, see <em>Notes</em> subsection below.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>NumPy array</strong>: The array with Y-values of the functin; Y = Lorenzian(X).</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>Pseudo-Voigt function\n= linear combination of Gaussian and Lorentzian function.</li>\n<li>In the 1st approximation:\n<ul>\n<li>50/50 combination =&gt; n = 0.5</li>\n<li>sg = sigma_Gaussian\ndefined so that sg and s yielded the same FWHM</li>\n</ul></li>\n<li>more details in:\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Voigt_profile\"><a href=\"https://en.wikipedia.org/wiki/Voigt_profile\">https://en.wikipedia.org/wiki/Voigt_profile</a></a></li>\n<li><a href=\"https://lmfit.github.io/lmfit-py/builtin_models.html\"><a href=\"https://lmfit.github.io/lmfit-py/builtin_models.html\">https://lmfit.github.io/lmfit-py/builtin_models.html</a></a></li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">s</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mf\">0.5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation", "kind": "class", "doc": "<p>Define calculation of PXRD = powder X-ray diffraction pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>crystal</strong> (ediff.pxrd.Crystal object):\nThis object is usually prepared in advance\nas an instance of ediff.pxrd.Crystal class.</li>\n<li><strong>experiment</strong> (ediff.pxrd.Experiment object):\nThis object is usually prepared in advance\nas an instance of ediff.pxrd.Experiment class.</li>\n<li><strong>plot_parameters</strong> (ediff.pxrd.PlotParameters object):\nThis object is usually prepared in advance\nas an instance of ediff.pxrd.PlotParameters class.</li>\n<li><strong>peak_profile_sigma</strong> (float, optional, the default is 0.03):\nWidth of the calculated diffraction peaks.\nThe default = 0.03 is suitable for most of common calculations\nand corresponds to the default in older PowderCell program (n*FWHM=7).\nFor overlapping peaks it may be slightly decreased,\nwhile for more realistic diffractograms it may be slightly increased.</li>\n<li><strong>peak_profile_type</strong> (None or ediff.pxrd.PeakProfiles object, optional):\nProfile of the calculated diffraction peaks.\nThe default is PeakProfiles.pseudo_voigt.\nThis default is suitable for common calculations\nand does not have to be changed (in great majority of cases).</li>\n</ul>\n"}, {"fullname": "ediff.pxrd.PXRDcalculation.__init__", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.__init__", "kind": "function", "doc": "<p>Initialize PXRDcalcualtion object.\nThe parameters are described above in class definition.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">crystal</span>,</span><span class=\"param\">\t<span class=\"n\">experiment</span>,</span><span class=\"param\">\t<span class=\"n\">plot_parameters</span>,</span><span class=\"param\">\t<span class=\"n\">peak_profile_sigma</span><span class=\"o\">=</span><span class=\"mf\">0.03</span>,</span><span class=\"param\">\t<span class=\"n\">peak_profile_type</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">PeakProfiles</span><span class=\"o\">.</span><span class=\"n\">pseudo_voigt</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "ediff.pxrd.PXRDcalculation.crystal", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.crystal", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.pxrd.PXRDcalculation.experiment", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.experiment", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.pxrd.PXRDcalculation.plot_parameters", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.plot_parameters", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.pxrd.PXRDcalculation.peak_profile_sigma", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.peak_profile_sigma", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.pxrd.PXRDcalculation.peak_profile_type", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.peak_profile_type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.pxrd.PXRDcalculation.diffractions", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.diffractions", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.pxrd.PXRDcalculation.diffractogram", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.diffractogram", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ediff.pxrd.PXRDcalculation.calculate_diffractions", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.calculate_diffractions", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.calculate_diffractogram", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.calculate_diffractogram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.print_diffractions", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.print_diffractions", "kind": "function", "doc": "<p>Print the calculated diffractions to stdout.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.save_diffractions", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.save_diffractions", "kind": "function", "doc": "<p>Save the calculated diffractions to <em>output_file</em>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>output_file</strong> (str):\nName of the output file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None; the output is the list of diffractions in the <em>output_file</em>.</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">output_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.plot_diffractions", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.plot_diffractions", "kind": "function", "doc": "<p>Plot the calculated diffractions.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>outfile</strong> (str, optional, the default is none):\nName of the output file.\nIf not given, the plot is just shown, but not saved.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The output is the plot on the screen (and outfile).\nThis function plots just diffraction intensities,\nnot profiles.\nUse ediff.pxrd.plot_diffractions\nfor diffractogram with intensity profiles.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">outfile</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.plot_diffractions_with_indexes", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.plot_diffractions_with_indexes", "kind": "function", "doc": "<p>Plot indexed diffractions.</p>\n\n<h2 id=\"important-interactive-plots-in-spyder\">Important - interactive plots in Spyder</h2>\n\n<ul>\n<li>This function can create interactive plot.\n<ul>\n<li>In CLI (command line) - the plot is interactive automatically.</li>\n<li>In Spyder IDE - default is to create non-interactive plots.</li>\n</ul></li>\n<li>If you want the interactive plot in Spyder IDE, type in Console ...\n<ul>\n<li>BEFORE running (to switch on interactivity): %matplotlib qt</li>\n<li>AFTER running (back to non-interactive mode): %matplotlib inline</li>\n</ul></li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>* None; this function is to be called exclusively</strong>: as method of PXRDcalculation object.</li>\n<li><strong>* If PXRDcalculation is properly initialized,</strong>: additional parameters are not needed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>* None; the output is the plot in the screen.</strong></li>\n<li><strong>* In typical case, the plot is interactive</strong>: so that the indexed diffractions could be expected in detail.</li>\n</ul>\n\n<h6 id=\"technical-notes\">Technical notes</h6>\n\n<ul>\n<li>The code below uses (sligthly modified) PyMatGen functions.</li>\n<li>Reason: PyMatGen plotting works well with diffraction indexes.\nRe-programing of indexed plots would be difficult and useless...</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.print_diffractogram", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.print_diffractogram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.save_diffractogram", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.save_diffractogram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">outfile</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.plot_diffractogram", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.plot_diffractogram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">outfile</span>, </span><span class=\"param\"><span class=\"n\">x_axis</span><span class=\"o\">=</span><span class=\"s1\">&#39;q&#39;</span>, </span><span class=\"param\"><span class=\"n\">dpi</span><span class=\"o\">=</span><span class=\"mi\">300</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.diffractions_to_dframe", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.diffractions_to_dframe", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">intensities</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.dframe_to_table", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.dframe_to_table", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dframe</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.add_diffraction_vectors_to_diffractogram", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.add_diffraction_vectors_to_diffractogram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.pxrd.PXRDcalculation.set_plot_details", "modulename": "ediff.pxrd", "qualname": "PXRDcalculation.set_plot_details", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x_axis</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.radial", "modulename": "ediff.radial", "kind": "module", "doc": "<h2 id=\"module-ediffradial\">Module: ediff.radial</h2>\n\n<p>The conversion of a 2D powder diffraction pattern\nto a 1D powder diffraction pattern = radially averaged intensity distribution.</p>\n"}, {"fullname": "ediff.radial.calc_radial_distribution", "modulename": "ediff.radial", "qualname": "calc_radial_distribution", "kind": "function", "doc": "<p>Calculate 1D radially averaged distrubution profile\nfrom 2D diffraction pattern.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (2D-numpy array):\nThe numpy array which contains the 2D-diffractogram.</li>\n<li><strong>center</strong> (tuple/list of two floats, optional, default is None):\nThe accurate coordinates of the 2D-diffractogram.\nThis argument should be determined by ediff.center.CenterLocator\nto get the best results.\nIf not given (= if it defaults to None), the center is determined\nan approximate procedure using intensity center,\nwithout any refinement;\nthis is imprecise, especially in case of\ndiffraction patterns with a beamstopper.</li>\n<li><strong>output_file</strong> (str, optional, default is None):\nName of the output file.\nIf given, the calculated 1D profile is saved to <em>output_file</em>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>profile</strong> (2D numpy array containing two rows [R,I]):\n<ul>\n<li>R = radial_distance = dist. from the diffractogram center [pixels]</li>\n<li>I = intensity = intensities at given distances [arbitrary units]</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">center</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.radial.save_radial_distribution", "modulename": "ediff.radial", "qualname": "save_radial_distribution", "kind": "function", "doc": "<p>Save 1D radially averaged distrubution profile to output_file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>profile</strong> (2D numpy array containing two rows [R,I]):\n<ul>\n<li>R = radial_distance = dist. from the diffractogram center [pixels]</li>\n<li>I = intensity = intensities at given distances [arbitrary units]</li>\n</ul></li>\n<li><strong>filename</strong> (str):\nName of the output file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None.</strong>: The output is the radial distribution saved in a file with <em>filename</em>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">profile</span>, </span><span class=\"param\"><span class=\"n\">output_file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ediff.radial.read_radial_distribution", "modulename": "ediff.radial", "qualname": "read_radial_distribution", "kind": "function", "doc": "<p>Read 1D-radially averaged distrubution profile from a TXT-file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>filename</strong> (str):\nName of the input file;\nthe file is expected to contain two columns [distance, intensity].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>arr</strong> (2D-numpy array):\nThe array containing two columns: distance, intensity.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();